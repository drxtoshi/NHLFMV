<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>+EV Finder | CBB + Polymarket</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <style>
    :root { --bg:#0a0a0f; --bg2:#12121a; --bg3:#1a1a25; --green:#00ff88; --red:#ff4757; --yellow:#ffd43b; --blue:#4dabf7; --purple:#9775fa; --text:#fff; --text2:#a0a0b0; --border:#2a2a3a; }
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family:'Space Grotesk',sans-serif; background:var(--bg); color:var(--text); min-height:100vh; }
    .mono { font-family:'JetBrains Mono',monospace; }
    .card { background:var(--bg2); border:1px solid var(--border); border-radius:12px; transition:all .2s; }
    .card:hover { border-color:rgba(0,255,136,.3); transform:translateY(-2px); }
    .tag { display:inline-flex; align-items:center; padding:4px 10px; border-radius:6px; font-size:12px; font-weight:500; }
    .tag-sharp { background:rgba(77,171,247,.15); color:var(--blue); border:1px solid rgba(77,171,247,.3); }
    .tag-soft { background:rgba(255,212,59,.15); color:var(--yellow); border:1px solid rgba(255,212,59,.3); }
    .tag-poly { background:rgba(151,117,250,.15); color:var(--purple); border:1px solid rgba(151,117,250,.3); }
    .tag-live { background:rgba(255,71,87,.2); color:var(--red); border:1px solid rgba(255,71,87,.4); animation:pulse 1.5s infinite; }
    .tag-upcoming { background:rgba(0,255,136,.1); color:var(--green); border:1px solid rgba(0,255,136,.3); }
    @keyframes pulse { 0%,100%{opacity:1} 50%{opacity:.6} }
    .btn { cursor:pointer; transition:all .2s; background:var(--bg3); border:1px solid var(--border); color:var(--text); padding:8px 16px; border-radius:8px; }
    .btn:hover { border-color:var(--green); }
    .btn-primary { background:linear-gradient(135deg,var(--green),#00cc6a); color:#000; font-weight:600; border:none; }
    .btn-danger { background:var(--red); color:#fff; border:none; }
    input,select { background:var(--bg3); border:1px solid var(--border); color:var(--text); padding:8px 12px; border-radius:8px; outline:none; }
    input:focus { border-color:var(--green); }
    .tab { padding:8px 16px; border-radius:8px; font-weight:500; cursor:pointer; }
    .tab.active { background:var(--green); color:#000; }
    .tab:not(.active) { background:var(--bg3); color:var(--text2); }
    .depth-table { font-size:11px; width:100%; }
    .depth-table th { text-align:left; color:var(--text2); padding:4px 6px; }
    .depth-table td { padding:4px 6px; }
    .live-dot { width:8px; height:8px; background:var(--red); border-radius:50%; display:inline-block; margin-right:6px; animation:pulse 1s infinite; }
    .error-box { background:rgba(255,71,87,.1); border:1px solid var(--red); border-radius:8px; padding:16px; margin-bottom:16px; }
    .success-box { background:rgba(0,255,136,.1); border:1px solid var(--green); border-radius:8px; padding:16px; margin-bottom:16px; }
    .api-input { font-family:'JetBrains Mono',monospace; font-size:12px; }
    .collapsible-header { cursor:pointer; user-select:none; }
  </style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
/*
 * ================================================================================
 * CLOUDFLARE WORKER CODE - Deploy this to handle both Gamma API and CLOB API
 * ================================================================================
 * Update your worker at: https://dash.cloudflare.com/
 * 
 * export default {
 *   async fetch(request) {
 *     const url = new URL(request.url);
 *     const path = url.pathname + url.search;
 *     
 *     let targetUrl;
 *     
 *     // Route CLOB requests to clob.polymarket.com
 *     if (path.startsWith('/clob/')) {
 *       const clobPath = path.replace('/clob/', '/');
 *       targetUrl = 'https://clob.polymarket.com' + clobPath;
 *     } else {
 *       // Route everything else to Gamma API
 *       targetUrl = 'https://gamma-api.polymarket.com' + path;
 *     }
 *     
 *     const response = await fetch(targetUrl, {
 *       method: request.method,
 *       headers: {
 *         'Accept': 'application/json',
 *         'User-Agent': 'PolymarketProxy/1.0'
 *       }
 *     });
 *     
 *     const data = await response.text();
 *     
 *     return new Response(data, {
 *       status: response.status,
 *       headers: {
 *         'Access-Control-Allow-Origin': '*',
 *         'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
 *         'Access-Control-Allow-Headers': 'Content-Type',
 *         'Content-Type': 'application/json',
 *         'Cache-Control': 'no-cache, no-store, must-revalidate'
 *       }
 *     });
 *   }
 * };
 * ================================================================================
 */

const { useState, useEffect, useCallback, useMemo } = React;

const SHARP = ['pinnacle','betonline','bovada'];
const TARGET = ['draftkings','fanduel','betmgm','caesars','espnbet','betrivers','fanatics','hardrockbet','polymarket'];
const BOOKS = {
  pinnacle:{n:'Pinnacle',t:'sharp',l:'ðŸ“Œ'}, betonline:{n:'BetOnline',t:'sharp',l:'ðŸ’»'}, bovada:{n:'Bovada',t:'sharp',l:'ðŸŽ°'},
  draftkings:{n:'DraftKings',t:'soft',l:'ðŸ‘‘'}, fanduel:{n:'FanDuel',t:'soft',l:'ðŸ¦…'}, betmgm:{n:'BetMGM',t:'soft',l:'ðŸ¦'}, caesars:{n:'Caesars',t:'soft',l:'ðŸ›ï¸'},
  espnbet:{n:'ESPN BET',t:'soft',l:'ðŸ“º'}, betrivers:{n:'BetRivers',t:'soft',l:'ðŸŒŠ'}, fanatics:{n:'Fanatics',t:'soft',l:'â­'}, hardrockbet:{n:'Hard Rock',t:'soft',l:'ðŸŽ¸'},
  polymarket:{n:'Polymarket',t:'soft',l:'ðŸ”®',ex:true}
};
const DEVIG = {
  mult:{n:'Multiplicative',d:'Conservative',f:p=>{const t=p.reduce((a,b)=>a+b,0);return p.map(x=>x/t);}},
  add:{n:'Additive',d:'Equal vig',f:p=>{const t=p.reduce((a,b)=>a+b,0),v=(t-1)/p.length;return p.map(x=>Math.max(.01,x-v));}},
  power:{n:'Power',d:'Iterative',f:p=>{let k=1;for(let i=0;i<50;i++){const s=p.reduce((a,x)=>a+Math.pow(x,k),0);if(Math.abs(s-1)<.0001)break;k=k*Math.log(1)/Math.log(s)||k*.99;}return p.map(x=>Math.pow(x,k));}},
  shin:{n:'Shin',d:'Insider model',f:p=>{const t=p.reduce((a,b)=>a+b,0),z=(t-1)/(p.length-1);return p.map(x=>{const d=z*z+4*(1-z)*x*x/t;return(Math.sqrt(d)-z)/(2*(1-z));});}}
};

// API endpoints
const GAMMA_API = 'https://gamma-api.polymarket.com';
const CLOB_API = 'https://clob.polymarket.com';
const SGO_API = 'https://api.sportsgameodds.com/v2';

// CORS proxy for browser requests (use when running locally)
const CORS_PROXY = 'https://corsproxy.io/?';
const USE_PROXY = true; // Set to false if running on a server

const proxyUrl = (url) => USE_PROXY ? CORS_PROXY + encodeURIComponent(url) : url;

const a2p=a=>a>0?100/(a+100):Math.abs(a)/(Math.abs(a)+100);
const p2a=p=>{if(p<=0)return 9999;if(p>=1)return -9999;return p>=.5?Math.round(-100*p/(1-p)):Math.round(100*(1-p)/p);};
const fmtA=o=>o>0?`+${o}`:`${o}`;
const fmtU=a=>a>=1e6?`$${(a/1e6).toFixed(1)}M`:a>=1e3?`$${(a/1e3).toFixed(1)}K`:`$${a.toFixed(0)}`;
const fmtC=p=>`${(p*100).toFixed(1)}Â¢`;
const calcEV=(bp,fp)=>((fp*(1/bp-1))-(1-fp))*100;
const calcK=(bp,fp,f=.25)=>{const b=1/bp-1;return Math.max(0,((b*fp-(1-fp))/b)*f*100);};

const isToday = (date) => {
  const today = new Date();
  const d = new Date(date);
  return d.getDate() === today.getDate() && d.getMonth() === today.getMonth() && d.getFullYear() === today.getFullYear();
};

const isLive = (startTime) => {
  const now = new Date();
  const start = new Date(startTime);
  const threeHoursLater = new Date(start.getTime() + 3 * 60 * 60 * 1000);
  return now >= start && now <= threeHoursLater;
};

const formatGameTime = (startTime) => {
  const start = new Date(startTime);
  const now = new Date();
  if (isLive(startTime)) {
    const minsElapsed = Math.floor((now - start) / 60000);
    if (minsElapsed < 20) return { status: 'live', text: '1H', detail: `${minsElapsed}m in` };
    if (minsElapsed < 40) return { status: 'live', text: '2H', detail: `${minsElapsed}m in` };
    return { status: 'live', text: 'LIVE', detail: `${minsElapsed}m in` };
  }
  if (start > now) {
    const hours = start.getHours();
    const mins = start.getMinutes();
    const ampm = hours >= 12 ? 'PM' : 'AM';
    const h12 = hours % 12 || 12;
    const timeStr = `${h12}:${mins.toString().padStart(2,'0')} ${ampm}`;
    const month = start.toLocaleString('en-US', { month: 'short' });
    const day = start.getDate();
    return { status: 'upcoming', text: timeStr, detail: `${month} ${day}` };
  }
  return { status: 'final', text: 'FINAL', detail: '' };
};

// ============================================
// API FUNCTIONS
// ============================================

// Fetch from SportsGameOdds API
const fetchSportsGameOdds = async (apiKey, league = 'NCAAB') => {
  // SGO uses leagueID parameter
  const url = `${SGO_API}/events?leagueID=${league}&oddsAvailable=true`;
  console.log('SGO fetching:', url);
  const response = await fetch(url, {
    headers: { 
      'x-api-key': apiKey,
      'Accept': 'application/json'
    }
  });
  if (!response.ok) {
    const text = await response.text();
    console.error('SGO response error:', response.status, text);
    throw new Error(`SportsGameOdds API error: ${response.status}`);
  }
  const data = await response.json();
  console.log('SGO response:', data);
  return data;
};

// Fetch Polymarket basketball markets
const fetchPolymarketBasketball = async () => {
  const response = await fetch(proxyUrl(`${GAMMA_API}/markets?active=true&closed=false&limit=100`));
  if (!response.ok) throw new Error(`Polymarket API error: ${response.status}`);
  const markets = await response.json();
  return markets.filter(m => {
    const q = (m.question || '').toLowerCase();
    const tags = (m.tags || []).map(t => (t.label || t || '').toLowerCase());
    return tags.some(t => t.includes('basketball') || t.includes('nba') || t.includes('ncaa') || t.includes('cbb')) ||
           q.includes(' vs ') || q.includes(' to win');
  });
};

// Fetch CBB schedule from ESPN (current scoreboard - includes live + today's games)
const fetchESPNSchedule = async () => {
  try {
    const allGames = [];
    
    // ESPN's scoreboard endpoint returns today's games by default (in progress + scheduled)
    // No date parameter needed - this ensures we get the correct day regardless of timezone
    const url = `https://site.api.espn.com/apis/site/v2/sports/basketball/mens-college-basketball/scoreboard`;
    
    console.log('Fetching ESPN CBB scoreboard...');
    const res = await fetch(url);
    
    if (!res.ok) {
      console.log('ESPN fetch failed:', res.status);
      return [];
    }
    
    const data = await res.json();
    const events = data.events || [];
    
    console.log(`ESPN scoreboard: ${events.length} games`);
    
    // Parse ESPN events into a simpler format
    for (const event of events) {
      const competition = event.competitions?.[0];
      const homeTeam = competition?.competitors?.find(c => c.homeAway === 'home');
      const awayTeam = competition?.competitors?.find(c => c.homeAway === 'away');
      const status = competition?.status;
      
      const gameInfo = {
        id: event.id,
        name: event.name,
        shortName: event.shortName,
        homeTeam: homeTeam?.team?.displayName || homeTeam?.team?.name,
        homeAbbrev: homeTeam?.team?.abbreviation,
        homeScore: homeTeam?.score,
        awayTeam: awayTeam?.team?.displayName || awayTeam?.team?.name,
        awayAbbrev: awayTeam?.team?.abbreviation,
        awayScore: awayTeam?.score,
        // Status: STATUS_SCHEDULED, STATUS_IN_PROGRESS, STATUS_HALFTIME, STATUS_FINAL
        statusType: status?.type?.name,
        statusState: status?.type?.state, // 'pre', 'in', 'post'
        statusDetail: status?.type?.shortDetail || status?.type?.detail,
        clock: status?.displayClock,
        period: status?.period,
        startTime: event.date,
      };
      
      // Log live games for debugging
      if (gameInfo.statusState === 'in') {
        console.log(`LIVE: ${gameInfo.shortName} - ${gameInfo.statusDetail}`);
      }
      
      allGames.push(gameInfo);
    }
    
    const liveCount = allGames.filter(g => g.statusState === 'in').length;
    const preCount = allGames.filter(g => g.statusState === 'pre').length;
    const postCount = allGames.filter(g => g.statusState === 'post').length;
    
    console.log(`ESPN games: ${allGames.length} total (${liveCount} live, ${preCount} upcoming, ${postCount} final)`);
    
    return allGames;
  } catch (e) {
    console.error('ESPN fetch error:', e);
    return [];
  }
};

// Common team name mappings (Polymarket name -> ESPN variations)
const TEAM_ALIASES = {
  'uconn': ['connecticut', 'huskies'],
  'unc': ['north carolina', 'tar heels'],
  'usc': ['southern california', 'trojans'],
  'ucla': ['bruins'],
  'lsu': ['louisiana state', 'tigers'],
  'osu': ['ohio state', 'buckeyes'],
  'msu': ['michigan state', 'spartans'],
  'uk': ['kentucky', 'wildcats'],
  'ku': ['kansas', 'jayhawks'],
  'iu': ['indiana', 'hoosiers'],
  'nova': ['villanova'],
  'cuse': ['syracuse', 'orange'],
  'zags': ['gonzaga', 'bulldogs'],
  'uva': ['virginia', 'cavaliers'],
  'vt': ['virginia tech', 'hokies'],
  'uf': ['florida', 'gators'],
  'fsu': ['florida state', 'seminoles'],
  'gt': ['georgia tech', 'yellow jackets'],
  'nc state': ['north carolina state', 'wolfpack'],
  'ole miss': ['mississippi', 'rebels'],
  'tcu': ['texas christian', 'horned frogs'],
  'smu': ['southern methodist', 'mustangs'],
  'pitt': ['pittsburgh', 'panthers'],
  'cal': ['california', 'golden bears'],
  'ark': ['arkansas', 'razorbacks'],
  'aub': ['auburn', 'tigers'],
  'tenn': ['tennessee', 'volunteers'],
  'tex': ['texas', 'longhorns'],
  'baylor': ['bears'],
  'duke': ['blue devils'],
  'purdue': ['boilermakers'],
  'iowa': ['hawkeyes'],
  'wisconsin': ['badgers'],
  'illinois': ['fighting illini'],
  'michigan': ['wolverines'],
  'oregon': ['ducks'],
  'arizona': ['wildcats'],
  'houston': ['cougars'],
  'memphis': ['tigers'],
  'creighton': ['bluejays'],
  'marquette': ['golden eagles'],
  'xavier': ['musketeers'],
  'seton hall': ['pirates'],
  'providence': ['friars'],
  'st johns': ['red storm', 'saint johns'],
  'depaul': ['blue demons'],
  'butler': ['bulldogs'],
};

// Normalize team names for matching
const normalizeTeamName = (name) => {
  if (!name) return '';
  return name
    .toLowerCase()
    .replace(/\s+/g, ' ')
    .replace(/^(the\s+)/i, '')
    .replace(/\s*(university|college|state|st\.|st)\s*/gi, ' ')
    .replace(/[^a-z0-9\s]/g, '')
    .trim();
};

// Check if two team names match
const teamsMatch = (name1, name2) => {
  if (!name1 || !name2) return false;
  
  const n1 = normalizeTeamName(name1);
  const n2 = normalizeTeamName(name2);
  
  // Exact match after normalization
  if (n1 === n2) return true;
  
  // One contains the other (min 3 chars to avoid false positives)
  if (n1.length >= 3 && n2.length >= 3) {
    if (n1.includes(n2) || n2.includes(n1)) return true;
  }
  
  // Check aliases
  for (const [key, aliases] of Object.entries(TEAM_ALIASES)) {
    const allNames = [key, ...aliases];
    const n1Matches = allNames.some(a => n1.includes(a) || a.includes(n1));
    const n2Matches = allNames.some(a => n2.includes(a) || a.includes(n2));
    if (n1Matches && n2Matches) return true;
  }
  
  // Check if key words match (last word is often the mascot or city)
  const words1 = n1.split(' ').filter(w => w.length > 2);
  const words2 = n2.split(' ').filter(w => w.length > 2);
  
  // If the first significant word matches (usually the school name)
  if (words1[0] && words2[0] && words1[0] === words2[0]) return true;
  
  // If the last word matches (often mascot)
  if (words1.length > 0 && words2.length > 0) {
    const last1 = words1[words1.length - 1];
    const last2 = words2[words2.length - 1];
    if (last1 === last2 && last1.length > 4) return true;
  }
  
  // If any significant word matches (5+ chars to avoid common words)
  for (const w1 of words1) {
    for (const w2 of words2) {
      if (w1 === w2 && w1.length >= 5) return true;
    }
  }
  
  return false;
};

// Fetch CBB markets from Polymarket using series_id (like NHL tool)
// ========================================
// CONFIGURATION - UPDATE THIS AFTER DEPLOYING YOUR CLOUDFLARE WORKER
// ========================================
// Your worker needs to handle BOTH Gamma API and CLOB API requests:
//   - /events, /markets, /sports â†’ gamma-api.polymarket.com
//   - /clob/book, /clob/price â†’ clob.polymarket.com
// See worker code below for implementation
const POLYMARKET_PROXY = 'https://polymarket-proxy.imdrax.workers.dev';
// Example: 'https://polymarket-proxy.drax123.workers.dev'
// Leave as empty string '' to fall back to public proxies

const fetchPolymarketCBB = async () => {
  const debug = { totalMarkets: 0, vsMarkets: 0, basketballMatches: 0, sampleMarket: null, error: null, attempts: [] };
  
  try {
    console.log('Fetching Polymarket basketball (no ESPN dependency)...');
    
    const timestamp = Date.now();
    let allEvents = [];
    
    // Try multiple approaches to get CBB games
    const queries = [
      // CBB series with active filter
      `/events?series_id=10470&active=true&closed=false&limit=100&_t=${timestamp}`,
      // Also try tag_id for games (100639 is games tag per docs)
      `/events?series_id=10470&tag_id=100639&active=true&closed=false&limit=100&_t=${timestamp}`,
      // Try without series_id, just basketball tag
      `/events?tag_id=100381&active=true&closed=false&limit=100&_t=${timestamp}`,
    ];
    
    for (const query of queries) {
      try {
        console.log(`Trying: ${query}`);
        const res = await fetch(POLYMARKET_PROXY + query, {
          cache: 'no-store',
          headers: { 'Cache-Control': 'no-cache' }
        });
        
        if (res.ok) {
          const data = await res.json();
          debug.attempts.push(`âœ“ ${query.split('?')[0]}: ${data.length || 0} events`);
          if (Array.isArray(data) && data.length > 0) {
            console.log(`Got ${data.length} events from query`);
            // Merge unique events
            data.forEach(event => {
              if (!allEvents.find(e => e.id === event.id)) {
                allEvents.push(event);
              }
            });
          }
        } else {
          debug.attempts.push(`âœ— ${query.split('?')[0]}: HTTP ${res.status}`);
        }
      } catch (e) {
        console.log(`Query error:`, e.message);
        debug.attempts.push(`âœ— ${query.split('?')[0]}: ${e.message}`);
      }
    }
    
    // Fallback: Fetch with larger limit if we got nothing
    if (allEvents.length === 0) {
      const fallbackQuery = `/events?series_id=10470&closed=false&limit=500&_t=${timestamp}`;
      console.log('Fallback query:', fallbackQuery);
      try {
        const res = await fetch(POLYMARKET_PROXY + fallbackQuery, {
          cache: 'no-store',
          headers: { 'Cache-Control': 'no-cache' }
        });
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data)) {
            allEvents = data;
            console.log(`Fallback got ${data.length} events`);
            debug.attempts.push(`âœ“ Fallback: ${data.length} events`);
          }
        }
      } catch (e) {
        console.log('Fallback error:', e.message);
        debug.attempts.push(`âœ— Fallback: ${e.message}`);
      }
    }
    
    debug.totalMarkets = allEvents.length;
    console.log('Total CBB events fetched:', allEvents.length);
    
    // Log a sample event to see structure
    if (allEvents.length > 0) {
      const sampleActive = allEvents.find(e => e.active && !e.closed) || allEvents[0];
      console.log('Sample active event:', JSON.stringify(sampleActive, null, 2).substring(0, 1000));
      debug.sampleMarket = sampleActive;
    }
    
    if (allEvents.length === 0) {
      debug.error = 'Could not fetch basketball data from Polymarket';
      return { games: [], debug };
    }
    
    // Process ALL Polymarket events - no ESPN filtering
    const processed = [];
    const now = new Date();
    
    allEvents.forEach(event => {
      const title = event.title || '';
      const match = title.match(/(.+?)\s+vs\.?\s+(.+)/i);
      
      if (!match) return;
      if (!event.markets || event.markets.length === 0) return;
      
      const team1 = match[1].trim();
      const team2 = match[2].trim();
      const market = event.markets[0];
      
      let prices = [0.5, 0.5];
      let tokenIds = [];
      try {
        prices = JSON.parse(market.outcomePrices || '[0.5, 0.5]').map(Number);
      } catch (e) {}
      
      // Extract clobTokenIds for orderbook fetching
      try {
        tokenIds = JSON.parse(market.clobTokenIds || '[]');
        if (tokenIds.length >= 2) {
          console.log(`Token IDs for ${team1} vs ${team2}:`, tokenIds[0]?.substring(0, 20) + '...', tokenIds[1]?.substring(0, 20) + '...');
        }
      } catch (e) {
        console.log('Failed to parse clobTokenIds:', e.message);
      }
      
      // Skip settled games (price > 90% or < 10%)
      const isSettled = prices[0] >= 0.90 || prices[0] <= 0.10;
      if (isSettled) return;
      
      // Skip resolved/closed games
      if (event.resolved || market.resolved || event.closed || market.closed) return;
      
      console.log(`Poly market: ${team1} vs ${team2} - prices: [${prices[0].toFixed(3)}, ${prices[1].toFixed(3)}]`);
      
      // Determine game status from Polymarket data
      // Use the 'live' flag from Polymarket if available, otherwise check startTime
      let isLive = event.live === true;
      let isUpcoming = false;
      let statusText = '';
      
      const eventStartTime = event.startTime || event.startDate;
      if (eventStartTime) {
        const startTime = new Date(eventStartTime);
        const hoursUntilStart = (startTime - now) / (1000 * 60 * 60);
        
        // Game is upcoming if starting within 24 hours
        if (hoursUntilStart > 0 && hoursUntilStart < 24) {
          isUpcoming = true;
        }
        // Game might be live if it started within the last 3 hours and not marked as ended
        else if (hoursUntilStart <= 0 && hoursUntilStart > -3 && !event.ended) {
          isLive = true;
        }
      }
      
      // Check Polymarket's own live/ended flags
      if (event.live === true) isLive = true;
      if (event.ended === true) isLive = false;
      
      // Use score/elapsed from Polymarket if available
      if (event.score) statusText = event.score;
      if (event.elapsed) statusText = event.elapsed;
      if (event.period) statusText = event.period;
      
      processed.push({
        id: event.id || market.id || Math.random().toString(),
        question: title,
        team1,
        team2,
        team1Price: prices[0],
        team2Price: prices[1],
        team1Ask: { price: prices[0], size: 0, total: 0 },
        team2Ask: { price: prices[1], size: 0, total: 0 },
        team1TokenId: tokenIds[0] || null,
        team2TokenId: tokenIds[1] || null,
        conditionId: market.conditionId || null,
        volume: parseFloat(market.volume) || parseFloat(event.volume) || 0,
        startTime: eventStartTime || now.toISOString(),
        slug: event.slug,
        url: `https://polymarket.com/event/${event.slug || event.id}`,
        live: isLive,
        ended: event.ended || false,
        upcoming: isUpcoming,
        espnMatch: false,
        hasPolymarket: true,
        gameStatus: statusText,
        period: event.period || '',
        score: event.score || '',
        closed: event.closed || market.closed,
        resolved: event.resolved || market.resolved,
      });
    });
    
    const liveCount = processed.filter(g => g.live).length;
    const upcomingCount = processed.filter(g => g.upcoming).length;
    
    console.log(`Processed Polymarket games: ${processed.length}`);
    console.log(`  - Live: ${liveCount}`);
    console.log(`  - Upcoming: ${upcomingCount}`);
    
    debug.basketballMatches = processed.length;
    debug.liveCount = liveCount;
    debug.upcomingCount = upcomingCount;
    
    // Sort: live games first, then upcoming, then by start time
    let sortedGames = processed.sort((a, b) => {
      if (a.live && !b.live) return -1;
      if (!a.live && b.live) return 1;
      if (a.upcoming && !b.upcoming) return -1;
      if (!a.upcoming && b.upcoming) return 1;
      return new Date(a.startTime) - new Date(b.startTime);
    });
    
    // Fetch orderbooks for games that have token IDs (to get real liquidity data)
    const gamesWithTokens = sortedGames.filter(g => g.team1TokenId || g.team2TokenId);
    if (gamesWithTokens.length > 0) {
      console.log(`Fetching orderbooks for ${gamesWithTokens.length} games with tokens...`);
      debug.orderbookFetchAttempted = gamesWithTokens.length;
      
      try {
        const gamesWithOrderbooks = await fetchOrderbooksForGames(gamesWithTokens);
        
        // Merge orderbook data back into sorted games
        const orderbookMap = new Map(gamesWithOrderbooks.map(g => [g.id, g]));
        sortedGames = sortedGames.map(g => {
          const withBook = orderbookMap.get(g.id);
          if (withBook) {
            return withBook;
          }
          return g;
        });
        
        const gamesWithBooks = gamesWithOrderbooks.filter(g => g.hasOrderbook).length;
        debug.orderbookFetchSuccess = gamesWithBooks;
        console.log(`Got orderbook data for ${gamesWithBooks} games`);
      } catch (err) {
        console.error('Orderbook fetch error:', err);
        debug.orderbookError = err.message;
      }
    }
    
    return { 
      games: sortedGames, 
      debug 
    };
  } catch (err) {
    console.error('Polymarket fetch error:', err);
    debug.error = err.message;
    return { games: [], debug };
  }
};

// Fetch orderbook for a Polymarket token (via proxy to avoid CORS)
const fetchOrderbook = async (tokenId) => {
  if (!tokenId) return null;
  try {
    // Use the proxy for CLOB API to avoid CORS issues
    const url = `${POLYMARKET_PROXY}/clob/book?token_id=${tokenId}`;
    console.log('Fetching orderbook:', tokenId.substring(0, 20) + '...');
    const response = await fetch(url, {
      cache: 'no-store',
      headers: { 'Cache-Control': 'no-cache' }
    });
    if (!response.ok) {
      console.log('Orderbook fetch failed:', response.status);
      return null;
    }
    const data = await response.json();
    console.log('Orderbook data:', { 
      bids: data.bids?.length || 0, 
      asks: data.asks?.length || 0,
      bestBid: data.bids?.[0]?.price,
      bestAsk: data.asks?.[0]?.price
    });
    return data;
  } catch (err) { 
    console.log('Orderbook error:', err.message);
    return null; 
  }
};

// Fetch orderbooks for multiple tokens in parallel (with rate limiting)
const fetchOrderbooksForGames = async (games) => {
  console.log(`Fetching orderbooks for ${games.length} games...`);
  
  // Collect all token IDs that need fetching
  const tokensToFetch = [];
  games.forEach(game => {
    if (game.team1TokenId) tokensToFetch.push({ gameId: game.id, team: 'team1', tokenId: game.team1TokenId });
    if (game.team2TokenId) tokensToFetch.push({ gameId: game.id, team: 'team2', tokenId: game.team2TokenId });
  });
  
  if (tokensToFetch.length === 0) {
    console.log('No tokens to fetch orderbooks for');
    return games;
  }
  
  console.log(`Fetching ${tokensToFetch.length} orderbooks...`);
  
  // Fetch in batches of 5 to avoid rate limits (200 requests / 10s for /book)
  const BATCH_SIZE = 5;
  const orderbooks = new Map();
  
  for (let i = 0; i < tokensToFetch.length; i += BATCH_SIZE) {
    const batch = tokensToFetch.slice(i, i + BATCH_SIZE);
    const results = await Promise.all(
      batch.map(async ({ gameId, team, tokenId }) => {
        const book = await fetchOrderbook(tokenId);
        return { gameId, team, tokenId, book };
      })
    );
    results.forEach(r => {
      if (r.book) {
        const key = `${r.gameId}-${r.team}`;
        orderbooks.set(key, r.book);
      }
    });
    
    // Small delay between batches to respect rate limits
    if (i + BATCH_SIZE < tokensToFetch.length) {
      await new Promise(resolve => setTimeout(resolve, 100));
    }
  }
  
  console.log(`Got ${orderbooks.size} orderbooks`);
  
  // Update games with orderbook data
  return games.map(game => {
    const team1Book = orderbooks.get(`${game.id}-team1`);
    const team2Book = orderbooks.get(`${game.id}-team2`);
    
    let team1Ask = game.team1Ask;
    let team2Ask = game.team2Ask;
    
    if (team1Book?.asks?.length > 0) {
      const bestAsk = team1Book.asks[0];
      const price = parseFloat(bestAsk.price);
      const size = parseFloat(bestAsk.size);
      team1Ask = {
        price: price,
        size: size,
        total: price * size,
        depth: team1Book.asks.slice(0, 5).map(a => ({
          price: parseFloat(a.price),
          size: parseFloat(a.size),
          total: parseFloat(a.price) * parseFloat(a.size)
        }))
      };
    }
    
    if (team2Book?.asks?.length > 0) {
      const bestAsk = team2Book.asks[0];
      const price = parseFloat(bestAsk.price);
      const size = parseFloat(bestAsk.size);
      team2Ask = {
        price: price,
        size: size,
        total: price * size,
        depth: team2Book.asks.slice(0, 5).map(a => ({
          price: parseFloat(a.price),
          size: parseFloat(a.size),
          total: parseFloat(a.price) * parseFloat(a.size)
        }))
      };
    }
    
    return {
      ...game,
      team1Ask,
      team2Ask,
      hasOrderbook: !!(team1Book || team2Book)
    };
  });
};

// Process SportsGameOdds API response
const processSGOData = (response) => {
  console.log('Processing SGO data:', response);
  // SGO returns { data: [...] } or just an array
  const events = response.data || response.items || response.events || (Array.isArray(response) ? response : []);
  console.log('SGO events to process:', events.length);
  
  return events.map(event => {
    // SGO event structure
    const homeTeam = event.homeTeam?.names?.medium || event.homeTeam?.names?.short || event.homeTeam?.name || event.teams?.home?.name || event.home_team || 'Home';
    const awayTeam = event.awayTeam?.names?.medium || event.awayTeam?.names?.short || event.awayTeam?.name || event.teams?.away?.name || event.away_team || 'Away';
    
    const gameData = {
      id: event.eventID || event.id || event.event_id,
      home: homeTeam,
      away: awayTeam,
      time: event.startTime || event.starts || event.start_time || event.commence_time || new Date().toISOString(),
      odds: { ml: { m: 'ml', ln: null, bk: {} } },
      poly: null,
      source: 'sportsgameodds'
    };
    
    // SGO odds structure - they use oddIDs like "points-home-game-ml-home"
    const odds = event.odds || {};
    
    // Map SGO bookmaker IDs to our keys
    const sgoBookMap = {
      'pinnacle': 'pinnacle',
      'betonline': 'betonline', 
      'bovada': 'bovada',
      'draftkings': 'draftkings',
      'fanduel': 'fanduel',
      'betmgm': 'betmgm',
      'caesars': 'caesars',
      'williamhill': 'caesars',
      'espnbet': 'espnbet',
      'betrivers': 'betrivers',
      'fanatics': 'fanatics',
      'hardrock': 'hardrockbet',
    };
    
    // Look for moneyline odds in various formats
    Object.entries(odds).forEach(([oddKey, oddValue]) => {
      // SGO format: odds are nested by bookmaker
      if (typeof oddValue === 'object' && oddValue !== null) {
        Object.entries(oddValue).forEach(([bookId, bookData]) => {
          const bookLower = bookId.toLowerCase();
          const mappedBook = Object.entries(sgoBookMap).find(([k]) => bookLower.includes(k))?.[1];
          
          if (mappedBook && bookData) {
            // Check if this is ML odds
            if (oddKey.includes('ml') || oddKey.includes('moneyline') || oddKey.includes('h2h')) {
              const price = bookData.price || bookData.american || bookData.odds || bookData;
              if (typeof price === 'number') {
                if (oddKey.includes('home')) {
                  gameData.odds.ml.bk[mappedBook] = gameData.odds.ml.bk[mappedBook] || { av: true };
                  gameData.odds.ml.bk[mappedBook].h = price;
                } else if (oddKey.includes('away')) {
                  gameData.odds.ml.bk[mappedBook] = gameData.odds.ml.bk[mappedBook] || { av: true };
                  gameData.odds.ml.bk[mappedBook].a = price;
                }
              }
            }
          }
        });
      }
    });
    
    // Also check for direct bookmakers array format
    if (event.bookmakers) {
      event.bookmakers.forEach(bm => {
        const bookLower = (bm.key || bm.id || bm.name || '').toLowerCase();
        const mappedBook = Object.entries(sgoBookMap).find(([k]) => bookLower.includes(k))?.[1];
        
        if (mappedBook) {
          const h2h = bm.markets?.find(m => m.key === 'h2h' || m.key === 'moneyline');
          if (h2h && h2h.outcomes) {
            const homeOdds = h2h.outcomes.find(o => o.name === homeTeam || o.label === 'home');
            const awayOdds = h2h.outcomes.find(o => o.name === awayTeam || o.label === 'away');
            if (homeOdds && awayOdds) {
              gameData.odds.ml.bk[mappedBook] = {
                h: homeOdds.price || homeOdds.american,
                a: awayOdds.price || awayOdds.american,
                av: true
              };
            }
          }
        }
      });
    }
    
    console.log('SGO processed game:', gameData.home, 'vs', gameData.away, 'books:', Object.keys(gameData.odds.ml.bk));
    return gameData;
  }).filter(g => Object.keys(g.odds.ml.bk).length > 0 || true); // Keep all for now to debug
};

// Match Polymarket markets to Odds API events
const matchPolymarketToOdds = (polyMarkets, oddsEvents) => {
  const matched = [];
  
  polyMarkets.forEach(pm => {
    const q = (pm.question || '').toLowerCase();
    const outcomes = JSON.parse(pm.outcomes || '[]');
    const prices = JSON.parse(pm.outcomePrices || '[]').map(Number);
    const tokens = pm.clobTokenIds ? JSON.parse(pm.clobTokenIds) : [];
    
    // Try to find matching odds event
    let matchedEvent = null;
    for (const event of oddsEvents) {
      const homeLower = event.home.toLowerCase();
      const awayLower = event.away.toLowerCase();
      // Check if question contains both team names
      if (q.includes(homeLower.split(' ').pop()) && q.includes(awayLower.split(' ').pop())) {
        matchedEvent = event;
        break;
      }
    }
    
    if (matchedEvent) {
      // Add Polymarket data to matched event
      matchedEvent.poly = {
        h: { mid: prices[0] || 0.5, ask: prices[0] || 0.5, askSz: 0, askU: 0, tokenId: tokens[0], vol: parseFloat(pm.volume) || 0, bk: null },
        a: { mid: prices[1] || 0.5, ask: prices[1] || 0.5, askSz: 0, askU: 0, tokenId: tokens[1], vol: parseFloat(pm.volume) || 0, bk: null }
      };
      matchedEvent.marketUrl = `https://polymarket.com/event/${pm.slug}`;
    }
  });
  
  return oddsEvents;
};

// Generate mock data as fallback
const genMockData = () => {
  const teams=[['Duke','UNC'],['Kansas','Kentucky'],['Gonzaga','UCLA'],['Arizona','Oregon'],['Villanova','UConn'],['Michigan St','Ohio St'],['Auburn','Tennessee'],['Houston','Memphis'],['Purdue','Indiana'],['Texas','Baylor']];
  const now = new Date();
  const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 0, 0, 0);
  const todayEnd = new Date(now.getFullYear(), now.getMonth(), now.getDate(), 23, 59, 59);
  
  return teams.map(([h,a],i)=>{
    const st = new Date(todayStart);
    if (i < 3) st.setHours(now.getHours(), now.getMinutes() - 30 - Math.floor(Math.random() * 60), 0);
    else {
      const baseHour = Math.max(now.getHours() + 1, 12);
      st.setHours(baseHour + Math.floor(i / 2), Math.floor(Math.random() * 60), 0);
    }
    if (st > todayEnd) st.setHours(22, Math.floor(Math.random() * 60), 0);
    if (st < todayStart) st.setTime(now.getTime() - Math.floor(Math.random() * 60) * 60000);
    
    const bp=.3+Math.random()*.4;
    const ev={id:`g${i}`,home:h,away:a,time:st.toISOString(),odds:{},poly:null,source:'mock'};
    
    if(Math.random()>.3){
      const ph=bp+(Math.random()*.04-.02);
      const mkBk=(mid)=>{
        const bids=[],asks=[];
        for(let j=0;j<5;j++){
          const bidP=Math.max(.01,mid-.005-j*.01-Math.random()*.005);
          const bidS=Math.round(1000+Math.random()*8000);
          bids.push({p:bidP,s:bidS,u:bidP*bidS});
          const askP=Math.min(.99,mid+.005+j*.01+Math.random()*.005);
          const askS=Math.round(1000+Math.random()*8000);
          asks.push({p:askP,s:askS,u:askP*askS});
        }
        bids.sort((x,y)=>y.p-x.p);asks.sort((x,y)=>x.p-y.p);
        return {bids,asks};
      };
      const hBk=mkBk(ph),aBk=mkBk(1-ph);
      ev.poly={
        h:{mid:ph,ask:hBk.asks[0].p,askSz:hBk.asks[0].s,askU:hBk.asks[0].u,bk:hBk,vol:Math.round(1e4+Math.random()*1e5)},
        a:{mid:1-ph,ask:aBk.asks[0].p,askSz:aBk.asks[0].s,askU:aBk.asks[0].u,bk:aBk,vol:Math.round(1e4+Math.random()*1e5)}
      };
    }
    ['ml','sp','tot'].forEach(m=>{
      const ln=m==='sp'?Math.round((bp-.5)*20*2)/2:m==='tot'?130+Math.round(Math.random()*30*2)/2:null;
      ev.odds[m]={m,ln,bk:{}};
      Object.keys(BOOKS).filter(b=>b!=='polymarket').forEach(b=>{
        const sh=BOOKS[b].t==='sharp';
        const vr=sh?.01:Math.random()*.05-.015;
        const vig=sh?1.02+Math.random()*.01:1.04+Math.random()*.03;
        let hO,aO;
        if(m==='ml'){hO=p2a(Math.min(.95,Math.max(.05,bp+vr))*vig);aO=p2a(Math.min(.95,Math.max(.05,1-bp-vr))*vig);}
        else{const base=-110,v=Math.floor(Math.random()*15)-7;hO=base+(sh?5:v);aO=base+(sh?5:-v);}
        ev.odds[m].bk[b]={h:hO,a:aO,av:Math.random()>.1};
      });
    });
    return ev;
  }).filter(ev => isToday(ev.time));
};

// ============================================
// COMPONENTS
// ============================================

const APIConfigPanel = ({ sgoApiKey, setSgoApiKey, apiStatus, onTestSgoAPI, onClearAPI }) => {
  const [isExpanded, setIsExpanded] = useState(!sgoApiKey);
  const [inputSgoKey, setInputSgoKey] = useState(sgoApiKey);
  
  return (
    <div className="card p-4 mb-6">
      <div className="collapsible-header flex items-center justify-between" onClick={() => setIsExpanded(!isExpanded)}>
        <h2 className="text-lg font-semibold flex items-center gap-2">
          ðŸ”‘ API Configuration
          {sgoApiKey && <span className="tag tag-sharp text-xs">Connected</span>}
        </h2>
        <span className="text-[#a0a0b0]">{isExpanded ? 'â–²' : 'â–¼'}</span>
      </div>
      
      {isExpanded && (
        <div className="mt-4 space-y-4">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
            {/* SportsGameOdds API */}
            <div className="p-4 bg-[#1a1a25] rounded-lg">
              <div className="flex items-center gap-2 mb-3">
                <span className="text-lg">ðŸŽ®</span>
                <h3 className="font-semibold">SportsGameOdds</h3>
              </div>
              <a href="https://sportsgameodds.com" target="_blank" rel="noopener" className="text-xs text-[#4dabf7] hover:underline block mb-2">Get API Key â†’</a>
              <p className="text-xs text-[#a0a0b0] mb-3">80+ books, props, alt lines. Pay per event.</p>
              <div className="flex gap-2">
                <input 
                  type="password" 
                  placeholder="API key..." 
                  value={inputSgoKey}
                  onChange={(e) => setInputSgoKey(e.target.value)}
                  className="flex-1 api-input text-xs"
                />
                <button 
                  onClick={() => { setSgoApiKey(inputSgoKey); onTestSgoAPI(inputSgoKey); }}
                  className="btn btn-primary text-xs px-3"
                >
                  Save
                </button>
              </div>
              {apiStatus.sgoApi && (
                <div className={`mt-2 text-xs ${apiStatus.sgoApi.success ? 'text-[#00ff88]' : 'text-[#ff4757]'}`}>
                  {apiStatus.sgoApi.message}
                </div>
              )}
            </div>
            
            {/* Polymarket - no key needed */}
            <div className="p-4 bg-[#1a1a25] rounded-lg">
              <div className="flex items-center gap-2 mb-3">
                <span className="text-lg">ðŸ”®</span>
                <h3 className="font-semibold">Polymarket</h3>
                <span className="tag tag-poly text-xs">Free</span>
              </div>
              <p className="text-xs text-[#a0a0b0] mb-3">No key required. Orderbook data auto-fetched.</p>
              <div className="flex items-center gap-2 text-sm text-[#00ff88]">
                <span className="w-2 h-2 bg-[#00ff88] rounded-full"></span>
                Ready to use
              </div>
            </div>
          </div>
          
          {sgoApiKey && (
            <div className="flex justify-end">
              <button onClick={onClearAPI} className="btn btn-danger text-sm">Clear API Key</button>
            </div>
          )}
          
          <div className="text-xs text-[#a0a0b0] bg-[#0a0a0f] p-3 rounded-lg">
            <strong>How it works:</strong> Sharp book odds (Pinnacle, BetOnline) are devigged to calculate fair value. 
            This fair value is compared against soft book odds AND Polymarket ask prices to find +EV.
          </div>
        </div>
      )}
    </div>
  );
};

const DepthTable=({bk,sel})=>{
  if(!bk?.asks)return null;
  let cum=0;
  const rows=bk.asks.slice(0,5).map(a=>{cum+=a.u;return{...a,cum};});
  return(
    <div className="mt-3 p-3 bg-[#0a0a0f] rounded-lg">
      <div className="text-xs text-[#a0a0b0] mb-2">ðŸ“Š Ask Depth - Buy {sel} YES</div>
      <table className="depth-table">
        <thead><tr><th>Price</th><th>American</th><th>Shares</th><th>$Cost</th><th>Cumul$</th></tr></thead>
        <tbody>{rows.map((r,i)=>(
          <tr key={i} style={{color:i===0?'#00ff88':'#a0a0b0'}}>
            <td className="mono">{fmtC(r.p)}</td>
            <td className="mono font-semibold">{fmtA(p2a(r.p))}</td>
            <td className="mono">{r.s.toLocaleString()}</td>
            <td className="mono">{fmtU(r.u)}</td>
            <td className="mono" style={{color:'#ffd43b'}}>{fmtU(r.cum)}</td>
          </tr>
        ))}</tbody>
      </table>
    </div>
  );
};

const GameTimeDisplay = ({ time }) => {
  const gt = formatGameTime(time);
  if (gt.status === 'live') {
    return (<div className="flex items-center gap-2"><span className="tag tag-live"><span className="live-dot"></span>{gt.text}</span><span className="text-xs text-[#a0a0b0]">{gt.detail}</span></div>);
  }
  if (gt.status === 'upcoming') {
    return (<div className="flex items-center gap-2"><span className="tag tag-upcoming">{gt.text}</span><span className="text-xs text-[#a0a0b0]">{gt.detail}</span></div>);
  }
  return <span className="text-xs text-[#a0a0b0]">FINAL</span>;
};

const EVCard=({b,onAlert})=>{
  const [showBk,setShowBk]=useState(false);
  const isPoly=b.book==='polymarket';
  const evCol=b.ev>=5?'#00ff88':b.ev>=2?'#4dabf7':'#ffd43b';
  const gameTime = formatGameTime(b.time);
  
  return(
    <div className="card p-4 relative">
      {isPoly&&<div className="absolute -top-2 -right-2 px-2 py-0.5 bg-[#9775fa] text-white text-xs rounded font-bold">POLY</div>}
      <div className="mb-3 pb-2 border-b border-[#2a2a3a]">
        <GameTimeDisplay time={b.time} />
      </div>
      <div className="flex justify-between mb-3">
        <div>
          <div className="flex gap-2 mb-1">
            <span className={`tag ${isPoly?'tag-poly':'tag-soft'}`}>{BOOKS[b.book]?.l || 'ðŸ“š'} {BOOKS[b.book]?.n || b.book}</span>
            <span className="text-xs text-[#a0a0b0]">{b.mkt}</span>
          </div>
          <h3 className="font-semibold">{b.sel}</h3>
          <p className="text-sm text-[#a0a0b0]">{b.home} vs {b.away}</p>
        </div>
        <div className="px-3 py-2 rounded-lg" style={{background:`${evCol}15`,border:`1px solid ${evCol}50`}}>
          <div className="text-2xl font-bold mono" style={{color:evCol}}>+{b.ev.toFixed(2)}%</div>
          <div className="text-xs text-[#a0a0b0]">EV</div>
        </div>
      </div>
      <div className="grid grid-cols-3 gap-4 py-3 border-t border-[#2a2a3a]">
        <div><div className="text-xs text-[#a0a0b0] mb-1">{isPoly?'Best Ask':'Book'}</div><div className="mono font-semibold text-lg">{fmtA(b.bookOdds)}</div>{isPoly&&b.pd&&<div className="text-xs text-[#9775fa]">{fmtC(b.pd.ask)}</div>}</div>
        <div><div className="text-xs text-[#a0a0b0] mb-1">Fair</div><div className="mono font-semibold text-lg text-[#4dabf7]">{fmtA(b.fair)}</div></div>
        <div><div className="text-xs text-[#a0a0b0] mb-1">Kelly</div><div className="mono font-semibold text-lg text-[#ffd43b]">{b.kelly.toFixed(1)}%</div></div>
      </div>
      {isPoly&&b.pd&&(
        <div className="pt-3 border-t border-[#2a2a3a]">
          <div className="grid grid-cols-2 gap-4 mb-2">
            <div><div className="text-xs text-[#a0a0b0]">Best Ask Liquidity</div><div className="mono text-[#00ff88] font-semibold">{fmtU(b.pd.askU)}</div><div className="text-xs text-[#a0a0b0]">{b.pd.askSz.toLocaleString()} @ {fmtC(b.pd.ask)} = {fmtA(p2a(b.pd.ask))}</div></div>
            <div><div className="text-xs text-[#a0a0b0]">24h Vol</div><div className="mono text-[#9775fa] font-semibold">{fmtU(b.pd.vol)}</div></div>
          </div>
          <button onClick={()=>setShowBk(!showBk)} className="w-full text-xs text-[#9775fa] py-2 bg-[#1a1a25] rounded-lg">{showBk?'â–² Hide':'â–¼ Show'} Full Depth (w/ American)</button>
          {showBk&&<DepthTable bk={b.pd.bk} sel={b.sel}/>}
        </div>
      )}
      <div className="flex justify-between pt-3 border-t border-[#2a2a3a] mt-3">
        <div className="text-xs text-[#a0a0b0]">
          {gameTime.status === 'live' ? <span className="text-[#ff4757]">âš¡ Live betting</span> : <span>Pre-game</span>}
        </div>
        <button onClick={()=>onAlert(b)} className="btn text-xs">ðŸ”” Alert</button>
      </div>
    </div>
  );
};

const PolymarketGameRow = ({ game, oddsFormat }) => {
  // Use ESPN-derived status or fallback to time-based
  const getGameStatus = () => {
    if (game.live) {
      return { 
        status: 'live', 
        text: game.period || 'LIVE', 
        detail: game.score || game.gameStatus || '',
        source: game.espnMatch ? 'espn' : 'heuristic'
      };
    }
    if (game.upcoming) {
      const start = new Date(game.startTime);
      const hours = start.getHours();
      const mins = start.getMinutes();
      const ampm = hours >= 12 ? 'PM' : 'AM';
      const h12 = hours % 12 || 12;
      const timeStr = `${h12}:${mins.toString().padStart(2,'0')} ${ampm}`;
      return { status: 'upcoming', text: timeStr, detail: '', source: game.espnMatch ? 'espn' : 'heuristic' };
    }
    // Not matched or old game
    return { status: 'final', text: 'FINAL', detail: '', source: null };
  };
  
  const gt = getGameStatus();
  
  const formatOdds = (price) => {
    if (oddsFormat === 'american') return fmtA(p2a(price));
    return `${(price * 100).toFixed(1)}%`;
  };
  
  return (
    <div className="grid grid-cols-12 gap-4 items-center p-4 border-b border-[#2a2a3a] hover:bg-[#1a1a25]/50 transition-all">
      {/* Time */}
      <div className="col-span-2">
        {gt.status === 'live' ? (
          <div>
            <span className="tag tag-live"><span className="live-dot"></span>{gt.text}</span>
            {gt.source === 'espn' && <span className="text-xs text-[#00ff88] ml-1">ESPN</span>}
            {gt.detail && <div className="text-xs text-[#a0a0b0] mt-1">{gt.detail}</div>}
          </div>
        ) : gt.status === 'upcoming' ? (
          <div>
            <span className="tag tag-upcoming">{gt.text}</span>
            {game.espnMatch && <span className="text-xs text-[#00ff88] ml-1">ESPN</span>}
          </div>
        ) : (
          <span className="text-[#a0a0b0] text-sm">{gt.text}</span>
        )}
      </div>
      
      {/* Teams */}
      <div className="col-span-3">
        <div className="font-semibold text-white">{game.team1}</div>
        <div className="text-[#a0a0b0]">{game.team2}</div>
        {!game.hasPolymarket && (
          <div className="text-xs text-[#ff4757] mt-1">No Polymarket</div>
        )}
      </div>
      
      {/* Team 1 Odds */}
      <div className="col-span-2 text-center">
        {game.hasPolymarket ? (
          <>
            <div className={`mono text-lg font-bold ${game.team1Ask.price > 0.5 ? 'text-[#00ff88]' : 'text-white'}`}>
              {formatOdds(game.team1Ask.price)}
            </div>
            <div className="text-xs text-[#a0a0b0]">{fmtC(game.team1Ask.price)}</div>
            {game.team1Ask.total > 0 ? (
              <div className="text-xs text-[#00ff88] mt-1 font-semibold">{fmtU(game.team1Ask.total)} liq âœ“</div>
            ) : (
              <div className="text-xs text-[#a0a0b0] mt-1">No orderbook</div>
            )}
          </>
        ) : (
          <div className="text-[#a0a0b0] text-sm">â€”</div>
        )}
      </div>
      
      {/* Team 2 Odds */}
      <div className="col-span-2 text-center">
        {game.hasPolymarket ? (
          <>
            <div className={`mono text-lg font-bold ${game.team2Ask.price > 0.5 ? 'text-[#00ff88]' : 'text-white'}`}>
              {formatOdds(game.team2Ask.price)}
            </div>
            <div className="text-xs text-[#a0a0b0]">{fmtC(game.team2Ask.price)}</div>
            {game.team2Ask.total > 0 ? (
              <div className="text-xs text-[#00ff88] mt-1 font-semibold">{fmtU(game.team2Ask.total)} liq âœ“</div>
            ) : (
              <div className="text-xs text-[#a0a0b0] mt-1">No orderbook</div>
            )}
          </>
        ) : (
          <div className="text-[#a0a0b0] text-sm">â€”</div>
        )}
      </div>
      
      {/* Volume */}
      <div className="col-span-2 text-center">
        {game.hasPolymarket ? (
          <>
            <div className="text-sm text-[#9775fa] font-semibold">{fmtU(game.volume)}</div>
            <div className="text-xs text-[#a0a0b0]">volume</div>
          </>
        ) : (
          <div className="text-xs text-[#a0a0b0]">N/A</div>
        )}
      </div>
      
      {/* Trade Link */}
      <div className="col-span-1 text-right">
        {game.hasPolymarket ? (
          <a href={game.url} target="_blank" rel="noopener noreferrer" className="btn text-xs px-3 py-1">Trade</a>
        ) : (
          <span className="text-xs text-[#a0a0b0]">â€”</span>
        )}
      </div>
    </div>
  );
};

const PolymarketGamesTab = ({ games, loading, oddsFormat, setOddsFormat, debugInfo }) => {
  const [showDebug, setShowDebug] = useState(false);
  const liveGames = games.filter(g => g.live === true);
  const upcomingGames = games.filter(g => g.upcoming === true && !g.live);
  const withPolymarket = games.filter(g => g.hasPolymarket);
  const totalVol = withPolymarket.reduce((sum, g) => sum + g.volume, 0);
  const totalLiq = withPolymarket.reduce((sum, g) => sum + (g.team1Ask?.total || 0) + (g.team2Ask?.total || 0), 0);
  
  return (
    <div>
      {/* Stats Row */}
      <div className="grid grid-cols-5 gap-4 mb-6">
        <div className="card p-4">
          <div className="text-sm text-[#a0a0b0]">ESPN Games</div>
          <div className="text-2xl font-bold mono text-white">{games.length}</div>
        </div>
        <div className="card p-4">
          <div className="text-sm text-[#a0a0b0]">Live Now</div>
          <div className="text-2xl font-bold mono text-[#ff4757]">{liveGames.length}</div>
        </div>
        <div className="card p-4">
          <div className="text-sm text-[#a0a0b0]">Has Polymarket</div>
          <div className="text-2xl font-bold mono text-[#9775fa]">{withPolymarket.length}</div>
        </div>
        <div className="card p-4">
          <div className="text-sm text-[#a0a0b0]">Total Volume</div>
          <div className="text-2xl font-bold mono text-[#9775fa]">{fmtU(totalVol)}</div>
        </div>
        <div className="card p-4">
          <div className="text-sm text-[#a0a0b0]">Total Liquidity</div>
          <div className="text-2xl font-bold mono text-[#00ff88]">{fmtU(totalLiq)}</div>
        </div>
      </div>
      
      {/* Odds Format Toggle */}
      <div className="flex justify-between items-center mb-4">
        <h3 className="text-lg font-semibold">ðŸ€ Basketball Markets on Polymarket</h3>
        <div className="flex gap-2 bg-[#1a1a25] rounded-lg p-1">
          <button 
            onClick={() => setOddsFormat('american')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition-all ${oddsFormat === 'american' ? 'bg-[#9775fa] text-white' : 'text-[#a0a0b0]'}`}
          >
            American
          </button>
          <button 
            onClick={() => setOddsFormat('percent')}
            className={`px-4 py-2 rounded-md text-sm font-medium transition-all ${oddsFormat === 'percent' ? 'bg-[#9775fa] text-white' : 'text-[#a0a0b0]'}`}
          >
            Percent
          </button>
        </div>
      </div>
      
      {/* Games Table */}
      <div className="card">
        {/* Header */}
        <div className="grid grid-cols-12 gap-4 p-4 border-b border-[#2a2a3a] text-sm text-[#a0a0b0] font-semibold bg-[#1a1a25] rounded-t-lg">
          <div className="col-span-2">Time</div>
          <div className="col-span-3">Matchup</div>
          <div className="col-span-2 text-center">Team 1</div>
          <div className="col-span-2 text-center">Team 2</div>
          <div className="col-span-2 text-center">Volume</div>
          <div className="col-span-1"></div>
        </div>
        
        {loading ? (
          <div className="p-12 text-center">
            <div className="w-8 h-8 border-4 border-[#9775fa] border-t-transparent rounded-full animate-spin mx-auto mb-4"></div>
            <p className="text-[#a0a0b0]">Loading Polymarket data...</p>
          </div>
        ) : games.length === 0 ? (
          <div className="p-12 text-center">
            <div className="text-4xl mb-4">ðŸ€</div>
            <p className="text-xl mb-2">No live or upcoming games</p>
            <p className="text-[#a0a0b0] mb-4">Only showing games confirmed by ESPN schedule.<br/>Check back when CBB games are in progress.</p>
            <div className="text-sm text-[#a0a0b0] mb-4">
              <div>ESPN games found today/tomorrow: <span className="text-white">{debugInfo?.espnGamesCount || 'checking...'}</span></div>
              <div>Polymarket markets fetched: <span className="text-white">{debugInfo?.totalMarkets || 0}</span></div>
            </div>
            <a href="https://www.espn.com/mens-college-basketball/schedule" target="_blank" rel="noopener" className="text-[#4dabf7] hover:underline">View ESPN CBB Schedule â†’</a>
          </div>
        ) : (
          games.map(game => (
            <PolymarketGameRow key={game.id} game={game} oddsFormat={oddsFormat} />
          ))
        )}
      </div>
      
      {/* Debug Panel */}
      <div className="mt-6">
        <button 
          onClick={() => setShowDebug(!showDebug)}
          className="btn text-xs mb-2"
        >
          {showDebug ? 'â–¼ Hide' : 'â–¶ Show'} Debug Info
        </button>
        
        {showDebug && (
          <div className="card p-4 bg-[#0a0a0f] text-xs mono overflow-auto max-h-96">
            <div className="mb-4">
              <div className="text-[#00ff88] font-bold mb-2">API Response Summary:</div>
              <div className="text-[#a0a0b0]">
                <div>Total Polymarket CBB markets: <span className="text-white">{debugInfo?.totalMarkets || 0}</span></div>
                <div>Active games (ESPN-matched live/upcoming): <span className="text-[#00ff88]">{debugInfo?.basketballMatches || 0}</span></div>
                <div>Filtered out (old/unmatched): <span className="text-[#ff4757]">{debugInfo?.filteredOut || 0}</span></div>
              </div>
            </div>
            
            <div className="mb-4">
              <div className="text-[#9775fa] font-bold mb-2">Orderbook Fetching (CLOB API):</div>
              <div className="text-[#a0a0b0]">
                <div>Games with token IDs: <span className="text-white">{debugInfo?.orderbookFetchAttempted || 0}</span></div>
                <div>Orderbooks fetched: <span className={debugInfo?.orderbookFetchSuccess > 0 ? 'text-[#00ff88]' : 'text-[#ff4757]'}>{debugInfo?.orderbookFetchSuccess || 0}</span></div>
                {debugInfo?.orderbookError && <div className="text-[#ff4757]">Error: {debugInfo.orderbookError}</div>}
              </div>
            </div>
            
            {debugInfo?.attempts?.length > 0 && (
              <div className="mb-4">
                <div className="text-[#4dabf7] font-bold mb-2">Fetch Attempts:</div>
                {debugInfo.attempts.map((attempt, i) => (
                  <div key={i} className={`text-xs mb-1 ${attempt.includes('âœ“') ? 'text-[#00ff88]' : 'text-[#ff4757]'}`}>
                    {i + 1}. {attempt}
                  </div>
                ))}
              </div>
            )}
            
            {debugInfo?.sampleMarket && (
              <div className="mb-4">
                <div className="text-[#ffd43b] font-bold mb-2">Sample Market Structure:</div>
                <pre className="text-[#a0a0b0] whitespace-pre-wrap break-all max-h-48 overflow-auto">
                  {JSON.stringify(debugInfo.sampleMarket, null, 2)}
                </pre>
              </div>
            )}
            
            {debugInfo?.error && (
              <div className="mb-4">
                <div className="text-[#ff4757] font-bold mb-2">Error:</div>
                <div className="text-[#ff4757]">{debugInfo.error}</div>
              </div>
            )}
            
            {debugInfo?.allTags?.length > 0 && (
              <div className="mb-4">
                <div className="text-[#4dabf7] font-bold mb-2">Tags Found:</div>
                <div className="text-[#a0a0b0] flex flex-wrap gap-1">
                  {debugInfo.allTags.map((tag, i) => (
                    <span key={i} className="bg-[#1a1a25] px-2 py-1 rounded">{tag}</span>
                  ))}
                </div>
              </div>
            )}
            
            {/* Show ESPN matching stats */}
            <div className="mb-4">
              <div className="text-[#00ff88] font-bold mb-2">Game Status Breakdown:</div>
              <div className="text-[#a0a0b0]">
                <div>ESPN Total: <span className="text-white">{debugInfo?.espnGamesCount || 0}</span></div>
                <div>ESPN Live: <span className="text-[#ff4757]">{debugInfo?.espnLiveCount || 0}</span></div>
                <div>With Polymarket: <span className="text-[#9775fa]">{debugInfo?.withPolymarket || 0}</span></div>
                <div>Polymarket Markets: <span className="text-white">{debugInfo?.totalPolymarketGames || 0}</span></div>
              </div>
            </div>
            
            {/* Show sample games */}
            {games.length > 0 && (
              <div className="mb-4">
                <div className="text-[#9775fa] font-bold mb-2">First 5 Games:</div>
                <div className="space-y-1">
                  {games.slice(0, 5).map((g, i) => (
                    <div key={i} className="text-xs text-[#a0a0b0]">
                      {g.live ? 'ðŸ”´' : g.upcoming ? 'ðŸŸ¢' : 'âšª'} {g.team1} vs {g.team2} 
                      {g.hasPolymarket ? ' [POLYâœ“]' : ' [no poly]'} 
                      {g.gameStatus ? ` (${g.gameStatus})` : ''}
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        )}
      </div>
    </div>
  );
};

// ============================================
// MAIN APP
// ============================================

const App=()=>{
  // Load API key from localStorage
  const [sgoApiKey, setSgoApiKey] = useState(() => localStorage.getItem('sgoApiKey') || '');
  const [apiStatus, setApiStatus] = useState({});
  
  const [data,setData]=useState([]);
  const [loading,setLoading]=useState(false);
  const [error,setError]=useState(null);
  const [dataSource,setDataSource]=useState('mock');
  const [auto,setAuto]=useState(false);
  const [tab,setTab]=useState('polymarket'); // Start on polymarket tab
  const [sharp,setSharp]=useState(['pinnacle']);
  const [target,setTarget]=useState(['draftkings','fanduel','betmgm','polymarket']);
  const [devig,setDevig]=useState('mult');
  const [minEV,setMinEV]=useState(1);
  const [minLiq,setMinLiq]=useState(0);
  const [sort,setSort]=useState('ev');
  const [oddsFormat, setOddsFormat] = useState('american'); // 'american' or 'percent'
  const [polyGames, setPolyGames] = useState([]);
  const [polyDebug, setPolyDebug] = useState({});
  const [alerts,setAlerts]=useState([]);
  const [currentTime, setCurrentTime] = useState(new Date());

  // Save API key to localStorage
  useEffect(() => {
    if (sgoApiKey) localStorage.setItem('sgoApiKey', sgoApiKey);
  }, [sgoApiKey]);

  useEffect(() => {
    const interval = setInterval(() => setCurrentTime(new Date()), 60000);
    return () => clearInterval(interval);
  }, []);

  const testSgoAPI = async (key) => {
    if (!key) return;
    try {
      setApiStatus(s => ({ ...s, sgoApi: { success: false, message: 'Testing...' } }));
      const response = await fetch(`${SGO_API}/sports?apiKey=${key}`, {
        headers: { 'x-api-key': key }
      });
      if (response.ok) {
        setApiStatus(s => ({ ...s, sgoApi: { success: true, message: 'âœ“ Connected!' } }));
      } else {
        throw new Error(`HTTP ${response.status}`);
      }
    } catch (err) {
      setApiStatus(s => ({ ...s, sgoApi: { success: false, message: `âœ— Error: ${err.message}` } }));
    }
  };

  const clearAPI = () => {
    setSgoApiKey('');
    localStorage.removeItem('sgoApiKey');
    setApiStatus({});
  };

  const fetchLiveData = useCallback(async () => {
    setLoading(true);
    setError(null);
    
    try {
      let oddsEvents = [];
      let polyMarkets = [];
      let apiErrors = [];
      
      // Always fetch Polymarket CBB games for the dedicated tab
      try {
        const result = await fetchPolymarketCBB();
        setPolyGames(result.games || []);
        setPolyDebug(result.debug || {});
        console.log('Polymarket games loaded:', (result.games || []).length);
      } catch (err) {
        console.error('Polymarket CBB error:', err);
        setPolyDebug({ error: err.message });
      }
      
      // Fetch from SportsGameOdds API if key is set
      if (sgoApiKey) {
        try {
          console.log('Fetching from SportsGameOdds...');
          const ncaabData = await fetchSportsGameOdds(sgoApiKey, 'NCAAB').catch(e => { console.log('SGO NCAAB error:', e); return { data: [] }; });
          const nbaData = await fetchSportsGameOdds(sgoApiKey, 'NBA').catch(e => { console.log('SGO NBA error:', e); return { data: [] }; });
          console.log('SGO raw data:', ncaabData, nbaData);
          const allData = [...(ncaabData.data || ncaabData.items || []), ...(nbaData.data || nbaData.items || [])];
          if (allData.length > 0) {
            oddsEvents = processSGOData({ data: allData });
            console.log('SGO processed events:', oddsEvents.length);
          }
        } catch (err) {
          console.error('SportsGameOdds API error:', err);
          apiErrors.push(`SportsGameOdds: ${err.message}`);
        }
      }
      
      // Fetch from Polymarket (always free)
      try {
        polyMarkets = await fetchPolymarketBasketball();
        console.log('Polymarket markets:', polyMarkets.length);
      } catch (err) {
        console.error('Polymarket error:', err);
      }
      
      // If we have odds data, try to match with Polymarket
      if (oddsEvents.length > 0) {
        const matched = matchPolymarketToOdds(polyMarkets, oddsEvents);
        const todayGames = matched.filter(g => isToday(g.time));
        setData(todayGames.length > 0 ? todayGames : matched);
        setDataSource('live');
        if (apiErrors.length > 0) setError(apiErrors.join('; '));
      } else if (polyMarkets.length > 0) {
        // No odds API data but have polymarket
        const processed = polyMarkets.map((pm, i) => {
          const outcomes = JSON.parse(pm.outcomes || '[]');
          const prices = JSON.parse(pm.outcomePrices || '[]').map(Number);
          const tokens = pm.clobTokenIds ? JSON.parse(pm.clobTokenIds) : [];
          return {
            id: pm.id || `poly_${i}`,
            home: outcomes[0] || 'Team A',
            away: outcomes[1] || 'Team B',
            time: pm.startDate || pm.endDate || new Date().toISOString(),
            odds: {},
            poly: {
              h: { mid: prices[0] || 0.5, ask: prices[0] || 0.5, askSz: 0, askU: 0, tokenId: tokens[0], vol: parseFloat(pm.volume) || 0 },
              a: { mid: prices[1] || 0.5, ask: prices[1] || 0.5, askSz: 0, askU: 0, tokenId: tokens[1], vol: parseFloat(pm.volume) || 0 }
            },
            source: 'polymarket-only',
            marketUrl: `https://polymarket.com/event/${pm.slug}`
          };
        });
        setData(processed);
        setDataSource('polymarket-only');
      } else {
        setData([]);
        setDataSource('live');
      }
    } catch (err) {
      console.error('Fetch error:', err);
      setError(`${err.message}`);
      setData([]);
      setDataSource('mock');
    }
    
    setLoading(false);
  }, [sgoApiKey]);

  const fetchMockData = useCallback(() => {
    setLoading(true);
    setError(null);
    setTimeout(() => {
      setData(genMockData());
      setDataSource('mock');
      setLoading(false);
    }, 500);
  }, []);

  useEffect(() => { fetchLiveData(); }, []);
  useEffect(() => { if(auto) { const i = setInterval(fetchLiveData, 60000); return () => clearInterval(i); } }, [auto, fetchLiveData]);

  const {all,poly,liveCount,upcomingCount}=useMemo(()=>{
    const bets=[];
    const incPoly=target.includes('polymarket');
    let live=0, upcoming=0;
    
    data.forEach(ev=>{
      const gameIsLive = isLive(ev.time);
      
      // Process sportsbook odds
      if (ev.odds?.ml?.bk) {
        const od = ev.odds.ml;
        const sOdds=[];
        sharp.forEach(bk=>{const o=od.bk[bk];if(o?.av)sOdds.push({h:a2p(o.h),a:a2p(o.a)});});
        
        if(sOdds.length > 0) {
          const avgH=sOdds.reduce((x,y)=>x+y.h,0)/sOdds.length;
          const avgA=sOdds.reduce((x,y)=>x+y.a,0)/sOdds.length;
          const dv=DEVIG[devig].f([avgH,avgA]);
          const fairH=dv[0],fairA=dv[1];
          
          // Check target books
          target.filter(b=>b!=='polymarket').forEach(bk=>{
            const o=od.bk[bk];if(!o?.av)return;
            const hP=a2p(o.h),hEV=calcEV(hP,fairH);
            if(hEV>=minEV){
              bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.home,side:'h',book:bk,bookOdds:o.h,fair:p2a(fairH),ev:hEV,kelly:calcK(hP,fairH),src:'sb',isLive:gameIsLive});
              if(gameIsLive)live++;else upcoming++;
            }
            const aP=a2p(o.a),aEV=calcEV(aP,fairA);
            if(aEV>=minEV){
              bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.away,side:'a',book:bk,bookOdds:o.a,fair:p2a(fairA),ev:aEV,kelly:calcK(aP,fairA),src:'sb',isLive:gameIsLive});
              if(gameIsLive)live++;else upcoming++;
            }
          });
          
          // Check Polymarket using fair value from sharp books
          if(incPoly && ev.poly){
            const ph=ev.poly.h;
            if(ph.ask>0 && (ph.askU>=minLiq || !ph.askU)){
              const hEV=calcEV(ph.ask,fairH);
              if(hEV>=minEV){
                bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.home,side:'h',book:'polymarket',bookOdds:p2a(ph.ask),fair:p2a(fairH),ev:hEV,kelly:calcK(ph.ask,fairH),src:'poly',pd:{ask:ph.ask,askSz:ph.askSz||0,askU:ph.askU||0,mid:ph.mid,vol:ph.vol,bk:ph.bk},isLive:gameIsLive,marketUrl:ev.marketUrl});
                if(gameIsLive)live++;else upcoming++;
              }
            }
            const pa=ev.poly.a;
            if(pa.ask>0 && (pa.askU>=minLiq || !pa.askU)){
              const aEV=calcEV(pa.ask,fairA);
              if(aEV>=minEV){
                bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.away,side:'a',book:'polymarket',bookOdds:p2a(pa.ask),fair:p2a(fairA),ev:aEV,kelly:calcK(pa.ask,fairA),src:'poly',pd:{ask:pa.ask,askSz:pa.askSz||0,askU:pa.askU||0,mid:pa.mid,vol:pa.vol,bk:pa.bk},isLive:gameIsLive,marketUrl:ev.marketUrl});
                if(gameIsLive)live++;else upcoming++;
              }
            }
          }
        }
      }
      
      // Polymarket only mode (no fair value)
      if (ev.source === 'polymarket-only' && incPoly && ev.poly) {
        const ph = ev.poly.h;
        bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.home,side:'h',book:'polymarket',bookOdds:p2a(ph.ask),fair:p2a(ph.mid),ev:0,kelly:0,src:'poly',pd:{ask:ph.ask,askSz:0,askU:0,mid:ph.mid,vol:ph.vol},isLive:gameIsLive,marketUrl:ev.marketUrl});
        const pa = ev.poly.a;
        bets.push({id:ev.id,home:ev.home,away:ev.away,time:ev.time,mkt:'ml',sel:ev.away,side:'a',book:'polymarket',bookOdds:p2a(pa.ask),fair:p2a(pa.mid),ev:0,kelly:0,src:'poly',pd:{ask:pa.ask,askSz:0,askU:0,mid:pa.mid,vol:pa.vol},isLive:gameIsLive,marketUrl:ev.marketUrl});
      }
    });
    
    bets.sort((a,b)=>{
      if(a.isLive && !b.isLive) return -1;
      if(!a.isLive && b.isLive) return 1;
      if(sort==='ev')return b.ev-a.ev;
      if(sort==='kelly')return b.kelly-a.kelly;
      if(sort==='liq')return (b.pd?.askU||0)-(a.pd?.askU||0);
      return new Date(a.time)-new Date(b.time);
    });
    return {all:bets,poly:bets.filter(x=>x.book==='polymarket'),liveCount:live,upcomingCount:upcoming};
  },[data,sharp,target,devig,minEV,minLiq,sort,currentTime]);

  const filtered=tab==='all'?all:tab==='poly'?poly:tab==='live'?all.filter(x=>x.isLive):tab==='upcoming'?all.filter(x=>!x.isLive):all.filter(x=>x.book!=='polymarket');
  const avgEV=all.length?all.reduce((a,b)=>a+b.ev,0)/all.length:0;
  const maxEV=all.length?Math.max(...all.map(x=>x.ev)):0;
  const totLiq=poly.reduce((a,b)=>a+(b.pd?.askU||0),0);
  
  const todayStr = new Date().toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });
  const sourceLabel = dataSource === 'live' ? 'ðŸŸ¢ Live' : dataSource === 'polymarket-only' ? 'ðŸŸ£ Poly Only' : 'ðŸŸ¡ Mock';

  return(
    <div className="min-h-screen">
      <header className="sticky top-0 z-50 bg-[#0a0a0f]/95 backdrop-blur border-b border-[#2a2a3a] px-6 py-4">
        <div className="max-w-[1800px] mx-auto flex justify-between items-center">
          <div className="flex items-center gap-3">
            <div className="w-10 h-10 rounded-xl bg-gradient-to-br from-[#00ff88] to-[#9775fa] flex items-center justify-center text-black font-bold text-lg">+</div>
            <div>
              <h1 className="text-xl font-bold" style={{background:'linear-gradient(135deg,#00ff88,#4dabf7)',WebkitBackgroundClip:'text',WebkitTextFillColor:'transparent'}}>EV Finder</h1>
              <p className="text-xs text-[#a0a0b0]">{todayStr} â€¢ {sourceLabel}</p>
            </div>
          </div>
          <div className="flex items-center gap-4">
            <div className="flex items-center gap-3 text-sm">
              <span className="flex items-center gap-1"><span className="live-dot"></span><span className="text-[#ff4757]">{liveCount} Live</span></span>
              <span className="text-[#a0a0b0]">|</span>
              <span className="text-[#00ff88]">{upcomingCount} Upcoming</span>
            </div>
            <button onClick={()=>setAuto(!auto)} className={`btn text-xs ${auto?'border-[#00ff88]':''}`}>{auto?'ðŸ”„':'â¸ï¸'} Auto</button>
            <button onClick={fetchMockData} className="btn text-xs">Mock</button>
            <span className={`w-2 h-2 rounded-full ${loading?'bg-yellow-400 animate-pulse':'bg-green-400'}`}></span>
            <button onClick={fetchLiveData} className="btn btn-primary">{loading?'...':'Refresh'}</button>
          </div>
        </div>
      </header>
      <main className="max-w-[1800px] mx-auto px-6 py-6">
        <APIConfigPanel 
          sgoApiKey={sgoApiKey}
          setSgoApiKey={setSgoApiKey}
          apiStatus={apiStatus}
          onTestSgoAPI={testSgoAPI}
          onClearAPI={clearAPI}
        />
        
        {error && <div className="error-box"><p className="text-[#ff4757] text-sm">{error}</p></div>}
        
        <div className="card p-6 mb-6">
          <h2 className="text-lg font-semibold mb-4">âš™ï¸ Filters</h2>
          <div className="grid grid-cols-1 lg:grid-cols-12 gap-4">
            <div className="lg:col-span-3"><label className="block text-sm text-[#a0a0b0] mb-2">Sharp Books (Fair Value)</label><div className="flex flex-wrap gap-2">{SHARP.map(b=><button key={b} onClick={()=>setSharp(sharp.includes(b)?sharp.filter(x=>x!==b):[...sharp,b])} className={`tag ${sharp.includes(b)?'tag-sharp':'bg-[#1a1a25] text-[#a0a0b0] border border-[#2a2a3a]'}`}>{BOOKS[b]?.l} {BOOKS[b]?.n}</button>)}</div></div>
            <div className="lg:col-span-4"><label className="block text-sm text-[#a0a0b0] mb-2">Target Books (Bet At)</label><div className="flex flex-wrap gap-2">{TARGET.map(b=><button key={b} onClick={()=>setTarget(target.includes(b)?target.filter(x=>x!==b):[...target,b])} className={`tag ${target.includes(b)?(b==='polymarket'?'tag-poly':'tag-soft'):'bg-[#1a1a25] text-[#a0a0b0] border border-[#2a2a3a]'}`}>{BOOKS[b]?.l} {BOOKS[b]?.n}</button>)}</div></div>
            <div className="lg:col-span-2"><label className="block text-sm text-[#a0a0b0] mb-2">Devig</label><select value={devig} onChange={e=>setDevig(e.target.value)} className="w-full">{Object.entries(DEVIG).map(([k,v])=><option key={k} value={k}>{v.n}</option>)}</select></div>
            <div className="lg:col-span-1"><label className="block text-sm text-[#a0a0b0] mb-2">Min EV</label><input type="number" value={minEV} onChange={e=>setMinEV(+e.target.value||0)} className="w-full mono"/></div>
            <div className="lg:col-span-2"><label className="block text-sm text-[#a0a0b0] mb-2">Min Liq</label><select value={minLiq} onChange={e=>setMinLiq(+e.target.value)} className="w-full"><option value={0}>Any</option><option value={500}>$500+</option><option value={1000}>$1K+</option><option value={2500}>$2.5K+</option><option value={5000}>$5K+</option></select></div>
          </div>
        </div>
        
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
          <div className="card p-4"><div className="text-sm text-[#a0a0b0]">Total +EV</div><div className="text-3xl font-bold mono" style={{background:'linear-gradient(135deg,#00ff88,#4dabf7)',WebkitBackgroundClip:'text',WebkitTextFillColor:'transparent'}}>{all.length}</div></div>
          <div className="card p-4"><div className="text-sm text-[#a0a0b0]">Avg EV</div><div className="text-3xl font-bold mono text-[#00ff88]">+{avgEV.toFixed(2)}%</div></div>
          <div className="card p-4"><div className="text-sm text-[#a0a0b0]">Best EV</div><div className="text-3xl font-bold mono text-[#00ff88]">+{maxEV.toFixed(2)}%</div></div>
          <div className="card p-4"><div className="text-sm text-[#a0a0b0]">Poly Opps</div><div className="text-3xl font-bold mono text-[#9775fa]">{poly.length}</div></div>
          <div className="card p-4"><div className="text-sm text-[#a0a0b0]">Poly Ask $</div><div className="text-2xl font-bold mono text-[#9775fa]">{fmtU(totLiq)}</div></div>
        </div>
        
        <div className="flex justify-between mb-4 flex-wrap gap-2">
          <div className="flex gap-2 flex-wrap">
            <button className={`tab ${tab==='polymarket'?'active':''}`} onClick={()=>setTab('polymarket')}>ðŸ”® Polymarket ({polyGames.length})</button>
            <button className={`tab ${tab==='all'?'active':''}`} onClick={()=>setTab('all')}>+EV All ({all.length})</button>
            <button className={`tab ${tab==='live'?'active':''}`} onClick={()=>setTab('live')}><span className="live-dot"></span>Live ({all.filter(x=>x.isLive).length})</button>
            <button className={`tab ${tab==='upcoming'?'active':''}`} onClick={()=>setTab('upcoming')}>â° Upcoming ({all.filter(x=>!x.isLive).length})</button>
            <button className={`tab ${tab==='poly'?'active':''}`} onClick={()=>setTab('poly')}>+EV Poly ({poly.length})</button>
            <button className={`tab ${tab==='sb'?'active':''}`} onClick={()=>setTab('sb')}>ðŸ“š Books ({all.filter(x=>x.book!=='polymarket').length})</button>
          </div>
          {tab !== 'polymarket' && <select value={sort} onChange={e=>setSort(e.target.value)} className="text-sm"><option value="ev">EV â†“</option><option value="kelly">Kelly â†“</option><option value="liq">Liquidity â†“</option><option value="time">Time â†‘</option></select>}
        </div>
        
        {/* Polymarket Tab */}
        {tab === 'polymarket' && (
          <PolymarketGamesTab 
            games={polyGames} 
            loading={loading} 
            oddsFormat={oddsFormat}
            setOddsFormat={setOddsFormat}
            debugInfo={polyDebug}
          />
        )}
        
        {/* +EV Tabs */}
        {tab !== 'polymarket' && (
          <>
            {loading&&!filtered.length?<div className="text-center py-20"><div className="w-12 h-12 border-4 border-[#00ff88] border-t-transparent rounded-full animate-spin mx-auto mb-4"></div><p className="text-[#a0a0b0]">Fetching data...</p></div>:
            !filtered.length?<div className="text-center py-20 card"><h3 className="text-xl">No +EV found</h3><p className="text-[#a0a0b0]">Add an Odds API key or adjust filters</p></div>:
            <div className="grid grid-cols-1 md:grid-cols-2 xl:grid-cols-3 2xl:grid-cols-4 gap-4">{filtered.map((b,i)=><EVCard key={`${b.id}-${b.sel}-${b.book}-${i}`} b={b} onAlert={x=>!alerts.find(a=>a.id===x.id&&a.sel===x.sel&&a.book===x.book)&&setAlerts([...alerts,x])}/>)}</div>}
          </>
        )}
      </main>
    </div>
  );
};

ReactDOM.render(<App/>,document.getElementById('root'));
</script>
</body>
</html>
