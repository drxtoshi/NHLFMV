<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CBB</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0a0e14;
            --bg2: #12171f;
            --bg3: #1a2028;
            --bg4: #242c38;
            --accent: #3b82f6;
            --accent2: #60a5fa;
            --profit: #22c55e;
            --profit-bg: rgba(34,197,94,0.1);
            --loss: #ef4444;
            --loss-bg: rgba(239,68,68,0.1);
            --warn: #f59e0b;
            --txt: #f1f5f9;
            --txt2: #94a3b8;
            --txt3: #64748b;
            --bdr: rgba(255,255,255,0.08);
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body { font-family:'Inter',system-ui,sans-serif; background:var(--bg); color:var(--txt); min-height:100vh; font-size:14px; }
        .app { max-width:1400px; margin:0 auto; padding:16px; }
        
        /* Header */
        .header { display:flex; justify-content:space-between; align-items:center; padding:12px 0 16px; border-bottom:1px solid var(--bdr); margin-bottom:16px; }
        .logo { display:flex; align-items:center; gap:10px; }
        .logo-icon { font-size:24px; }
        .logo h1 { font-size:18px; font-weight:600; }
        .controls { display:flex; gap:8px; align-items:center; }
        .status { display:flex; align-items:center; gap:6px; padding:6px 12px; background:var(--bg2); border-radius:6px; font-size:12px; color:var(--txt2); }
        .dot { width:6px; height:6px; border-radius:50%; background:var(--profit); }
        .dot.off { background:var(--loss); }
        .btn { padding:8px 14px; border:none; border-radius:6px; font-family:inherit; font-weight:500; font-size:13px; cursor:pointer; transition:all 0.15s; }
        .btn-primary { background:var(--accent); color:white; }
        .btn-primary:hover { background:var(--accent2); }
        .btn-secondary { background:var(--bg3); color:var(--txt2); border:1px solid var(--bdr); }
        .btn-secondary:hover { background:var(--bg4); color:var(--txt); }
        
        /* Config Panel */
        .config { background:var(--bg2); border:1px solid var(--bdr); border-radius:8px; padding:16px; margin-bottom:16px; display:none; }
        .config.show { display:block; }
        .config-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:16px; }
        .config-title { font-size:14px; font-weight:600; }
        .config-grid { display:grid; grid-template-columns:repeat(4, 1fr); gap:12px; }
        .field { display:flex; flex-direction:column; gap:6px; }
        .field label { font-size:11px; font-weight:500; color:var(--txt3); text-transform:uppercase; letter-spacing:0.5px; }
        .field input, .field select { padding:8px 10px; background:var(--bg); border:1px solid var(--bdr); border-radius:6px; color:var(--txt); font-family:inherit; font-size:13px; }
        .field input:focus, .field select:focus { outline:none; border-color:var(--accent); }
        
        /* Book Selector */
        .book-section { grid-column: span 2; }
        .book-selector { display:flex; flex-wrap:wrap; gap:6px; margin-top:4px; }
        .book-tag { padding:4px 10px; background:var(--bg); border:1px solid var(--bdr); border-radius:4px; font-size:12px; cursor:pointer; transition:all 0.15s; user-select:none; }
        .book-tag:hover { border-color:var(--txt3); }
        .book-tag.selected { background:var(--accent); border-color:var(--accent); color:white; }
        .book-tag.selected.sharp { background:var(--profit); border-color:var(--profit); }
        
        /* Stats Bar */
        .stats { display:flex; gap:8px; margin-bottom:12px; }
        .stat { background:var(--bg2); border:1px solid var(--bdr); border-radius:6px; padding:8px 12px; flex:1; }
        .stat-label { font-size:9px; color:var(--txt3); text-transform:uppercase; letter-spacing:0.5px; margin-bottom:2px; }
        .stat-value { font-size:16px; font-weight:600; }
        .stat-value.green { color:var(--profit); }
        .stat-value.blue { color:var(--accent); }
        
        /* Games */
        .games { display:grid; grid-template-columns:repeat(auto-fill, minmax(360px, 1fr)); gap:10px; }
        .game { background:var(--bg2); border:1px solid var(--bdr); border-radius:8px; overflow:hidden; position:relative; cursor:pointer; }
        .game.has-edge { border-color:var(--profit); }
        .game.has-edge::before { 
            content:''; 
            position:absolute; 
            inset:0; 
            background:var(--profit); 
            opacity:0; 
            pointer-events:none; 
            z-index:10;
            animation:edgePulse 2s ease-in-out infinite;
        }
        .game.has-edge.seen::before { animation:none; opacity:0; }
        @keyframes edgePulse {
            0%, 100% { opacity:0; }
            50% { opacity:0.15; }
        }
        
        /* Game Header */
        .game-header { display:flex; justify-content:space-between; align-items:center; padding:10px 12px; background:var(--bg3); position:relative; z-index:15; }
        .teams { display:flex; align-items:center; gap:6px; flex-wrap:nowrap; }
        .team { display:flex; flex-direction:column; align-items:flex-start; gap:1px; }
        .team-abbr { font-size:13px; font-weight:700; color:#fff; }
        .team-name { font-weight:400; font-size:10px; white-space:nowrap; color:var(--txt3); }
        .score { font-size:16px; font-weight:700; color:var(--accent); }
        .at { color:var(--txt3); font-size:11px; margin:0 2px; }
        .game-right { display:flex; align-items:center; gap:8px; }
        .game-info { display:flex; flex-direction:column; align-items:flex-end; gap:1px; }
        .game-info-row { display:flex; align-items:center; gap:6px; }
        .game-status { display:inline-flex; align-items:center; gap:4px; padding:2px 6px; border-radius:3px; font-size:10px; font-weight:500; }
        .game-status.live { background:var(--loss-bg); color:var(--loss); }
        .game-status.live .live-dot { width:6px; height:6px; background:var(--loss); border-radius:50%; animation:livePulse 1.5s ease-in-out infinite; }
        @keyframes livePulse { 0%, 100% { opacity:1; } 50% { opacity:0.4; } }
        .game-status.upcoming { background:transparent; color:var(--txt3); font-size:9px; padding:0; text-transform:uppercase; }
        .game-status.final { background:var(--bg); color:var(--txt3); }
        .game-time { font-size:14px; font-weight:600; color:var(--txt); }
        .game-time-tz { font-size:9px; color:var(--txt3); margin-left:3px; font-weight:400; }
        .game-clock { font-size:11px; color:var(--warn); font-weight:500; }
        .game-date { font-size:10px; color:var(--txt3); }
        
        /* Period Tabs */
        .period-tabs { display:flex; gap:3px; padding:6px 12px; background:var(--bg); border-bottom:1px solid var(--bdr); }
        .period-tab { padding:5px 12px; background:transparent; border:1px solid transparent; border-radius:4px; color:var(--txt3); font-family:inherit; font-size:11px; font-weight:500; cursor:pointer; transition:all 0.15s; position:relative; }
        .period-tab:hover { color:var(--txt); background:var(--bg3); }
        .period-tab.active { background:var(--accent); color:white; }
        .period-tab.has-edge::after { content:''; position:absolute; top:1px; right:1px; width:5px; height:5px; background:var(--profit); border-radius:50%; }
        .period-tab:disabled { opacity:0.4; cursor:default; }
        
        /* Odds Section */
        .odds-section { padding:10px 12px; }
        .odds-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:8px; }
        .odds-title { font-size:12px; font-weight:600; color:var(--txt2); }
        .consensus-pills { display:flex; gap:24px; }
        .pill-group { display:flex; gap:12px; }
        .pill { text-align:center; }
        .pill-label { font-size:9px; color:var(--txt3); text-transform:uppercase; }
        .pill-value { font-size:13px; font-weight:600; color:var(--accent); }
        
        /* Odds Table */
        .odds-table { width:100%; border-collapse:collapse; }
        .odds-table th { padding:6px 8px; text-align:left; font-size:9px; font-weight:600; color:var(--txt3); text-transform:uppercase; letter-spacing:0.5px; border-bottom:1px solid var(--bdr); }
        .odds-table td { padding:6px 8px; border-bottom:1px solid var(--bdr); font-size:12px; }
        .odds-table tr:last-child td { border-bottom:none; }
        .odds-table tr:hover { background:rgba(255,255,255,0.02); }
        .odds-table .consensus-row { background:var(--bg3); }
        .odds-table .consensus-row td { border-top:2px solid var(--accent); font-weight:500; }
        
        .book-cell { display:flex; align-items:center; gap:6px; }
        .book-logo { width:28px; height:18px; background:var(--bg4); border-radius:3px; display:flex; align-items:center; justify-content:center; font-size:8px; font-weight:700; color:#fff; }
        .book-name { font-weight:500; font-size:12px; }
        .book-badge { font-size:8px; padding:1px 4px; border-radius:2px; font-weight:600; }
        .book-badge.sharp { background:var(--profit-bg); color:var(--profit); }
        .book-badge.soft { background:rgba(59,130,246,0.1); color:var(--accent); }
        
        .odds-cell { text-align:center; }
        .odds-value { display:inline-block; padding:3px 6px; border-radius:3px; font-weight:500; min-width:50px; font-size:12px; color:var(--txt); }
        .odds-value.best { background:rgba(96,165,250,0.15); color:#60a5fa; }
        .odds-value.better { background:var(--profit-bg); color:var(--profit); }
        
        .ev-cell { text-align:center; }
        .ev-value { display:inline-block; padding:3px 6px; border-radius:3px; font-weight:600; min-width:55px; font-size:11px; color:var(--txt); }
        .ev-value.positive { background:var(--profit-bg); color:var(--profit); }
        .ev-value.negative { color:var(--txt3); }
        
        .signal-cell { }
        .edge-badge { display:inline-flex; align-items:center; gap:3px; padding:3px 6px; background:var(--profit); color:var(--bg); border-radius:3px; font-size:10px; font-weight:600; }
        
        /* Consensus row purple */
        .odds-table .consensus-row { background:rgba(168,85,247,0.08); }
        .odds-table .consensus-row td { border-top:2px solid #a855f7; font-weight:500; }
        .odds-table .consensus-row .odds-value { color:#c084fc; background:rgba(168,85,247,0.15); }
        .consensus-label { color:#a855f7; }
        
        /* Alerts - inline next to tabs */
        .alerts-inline { display:flex; flex-wrap:wrap; gap:8px; flex:1; overflow:hidden; }
        .alerts-inline:empty { display:none; }
        .alert { padding:8px 12px; background:var(--bg2); border:1px solid var(--profit); border-radius:6px; cursor:pointer; transition:all 0.15s; max-width:350px; }
        .alert:hover { background:var(--bg3); }
        .alert-header { display:flex; justify-content:space-between; align-items:center; margin-bottom:2px; }
        .alert-title { font-size:11px; font-weight:600; color:var(--profit); }
        .alert-time { font-size:9px; color:var(--txt3); }
        .alert-body { font-size:11px; color:var(--txt2); }
        .alert-body strong { color:var(--txt); }
        .alert-ev { display:inline-block; margin-left:6px; padding:2px 6px; background:var(--profit-bg); color:var(--profit); border-radius:3px; font-weight:600; font-size:10px; }
        
        /* Steam alerts - orange/yellow theme */
        .alert.steam-alert { border-color:var(--warn); background:rgba(245,158,11,0.08); }
        .alert.steam-alert .alert-title { color:var(--warn); }
        .steam-move { color:var(--warn); font-weight:600; font-size:10px; }
        
        /* Empty/Loading States */
        .empty { text-align:center; padding:48px 20px; color:var(--txt3); }
        .empty-icon { font-size:40px; margin-bottom:12px; }
        .empty h3 { font-size:16px; color:var(--txt2); margin-bottom:6px; }
        .loading { text-align:center; padding:32px; }
        .spinner { width:32px; height:32px; border:3px solid var(--bdr); border-top-color:var(--accent); border-radius:50%; animation:spin 1s linear infinite; margin:0 auto 12px; }
        @keyframes spin { to { transform:rotate(360deg); } }
        
        /* Debug */
        .debug { background:var(--bg2); border:1px solid var(--bdr); border-radius:6px; padding:12px; margin-top:16px; font-size:11px; font-family:monospace; max-height:180px; overflow-y:auto; display:none; }
        .debug pre { white-space:pre-wrap; word-break:break-all; color:var(--txt3); }
        
        /* Collapsed Game Mode */
        .game.collapsed .period-tabs,
        .game.collapsed .odds-section { display:none; }
        .game.collapsed .game-header { cursor:pointer; }
        .collapsed-summary { display:none; padding:6px 12px; background:var(--bg); border-top:1px solid var(--bdr); font-size:11px; }
        .game.collapsed .collapsed-summary { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
        .collapsed-summary .cs-item { display:flex; align-items:center; gap:4px; padding:3px 6px; background:var(--bg3); border-radius:4px; }
        .collapsed-summary .cs-label { color:var(--txt3); font-size:9px; font-weight:600; }
        .collapsed-summary .cs-value { font-weight:600; color:var(--txt); font-size:11px; }
        .collapsed-summary .cs-value.purple { color:#c084fc; }
        .collapsed-summary .cs-value.blue { color:var(--accent); }
        .collapsed-summary .cs-fv-stack { display:flex; flex-direction:column; gap:1px; padding:2px 6px; background:var(--bg3); border-radius:4px; }
        .collapsed-summary .cs-fv-item { display:flex; align-items:center; gap:4px; }
        .collapsed-summary .cs-best-stack { display:flex; flex-direction:column; gap:2px; }
        .collapsed-summary .cs-best-line { display:flex; align-items:center; gap:3px; }
        .collapsed-summary .cs-best-line .cs-side { font-weight:700; color:var(--txt); font-size:10px; width:10px; }
        .collapsed-summary .cs-best-line .book-logo { width:20px; height:13px; font-size:6px; border-radius:2px; display:inline-flex; align-items:center; justify-content:center; font-weight:700; color:#fff; flex-shrink:0; }
        .collapsed-summary .cs-best-line .cs-odds { color:var(--txt2); font-weight:500; font-size:10px; }
        
        /* Best bets bar (shown when expanded) */
        .best-bets-bar { display:flex; flex-wrap:wrap; gap:8px; padding:6px 12px; background:var(--bg); border-bottom:1px solid var(--bdr); align-items:center; }
        .best-bets-bar:empty { display:none; }
        .best-bets-label { font-size:10px; color:var(--txt3); font-weight:600; text-transform:uppercase; margin-right:4px; }
        .best-bets-stack { display:flex; flex-direction:column; gap:2px; }
        .best-bet-chip { display:flex; align-items:center; gap:3px; font-size:10px; }
        .best-bet-chip .bet-label { font-weight:700; color:var(--txt); width:10px; }
        .best-bet-chip .book-logo { width:20px; height:13px; font-size:6px; border-radius:2px; display:inline-flex; align-items:center; justify-content:center; font-weight:700; color:#fff; flex-shrink:0; }
        .best-bet-chip .bet-odds { color:var(--txt2); font-weight:500; }
        .game.collapsed .best-bets-bar { display:none; }
        
        /* Arbitrage bar */
        .arb-bar { display:flex; flex-wrap:wrap; gap:8px; padding:6px 12px; background:rgba(245,158,11,0.1); border-bottom:1px solid var(--warn); align-items:center; }
        .arb-bar:empty { display:none; }
        .arb-label { font-size:10px; color:var(--warn); font-weight:700; text-transform:uppercase; margin-right:4px; }
        .arb-chip { display:flex; align-items:center; gap:4px; font-size:10px; padding:4px 8px; background:var(--bg3); border-radius:4px; color:var(--txt); }
        .arb-chip .arb-type { font-weight:600; color:var(--txt3); font-size:9px; margin-right:2px; }
        .arb-chip .book-logo { width:20px; height:13px; font-size:6px; border-radius:2px; display:inline-flex; align-items:center; justify-content:center; font-weight:700; color:#fff; flex-shrink:0; }
        .arb-chip .arb-vs { color:var(--txt3); font-size:9px; margin:0 2px; }
        .arb-chip .arb-pct { color:var(--warn); font-weight:700; margin-left:4px; }
        .game.collapsed .arb-bar { display:none; }
        
        /* Pin Button */
        .pin-btn { background:none; border:none; cursor:pointer; font-size:14px; padding:4px; opacity:0.4; transition:all 0.15s; position:relative; z-index:20; }
        .pin-btn:hover { opacity:0.8; }
        .game.pinned .pin-btn { opacity:1; color:var(--warn); }
        .game.pinned { border-color:var(--warn); }
        
        /* Expand/Collapse Button per game */
        .expand-btn { background:none; border:none; cursor:pointer; font-size:12px; padding:4px 6px; color:var(--txt3); transition:all 0.15s; position:relative; z-index:20; }
        .expand-btn:hover { color:var(--txt); }
        .game.collapsed .expand-btn { transform:rotate(-90deg); }
        
        /* Header controls group */
        .game-controls { display:flex; align-items:center; gap:2px; margin-left:auto; position:relative; z-index:20; }
        
        /* Table scroll wrapper */
        .table-scroll { overflow-x:auto; }
        
        /* Line change indicators */
        .odds-value.changed-red { box-shadow:0 0 0 2px #ef4444; }
        .odds-value.changed-yellow { box-shadow:0 0 0 2px #f59e0b; }
        .line-arrow { font-size:10px; margin-left:2px; }
        .line-arrow.up { color:#ef4444; }
        .line-arrow.down { color:#22c55e; }
        
        /* Market sections for CBB */
        .market-section { margin-bottom:16px; }
        .market-header { font-size:12px; font-weight:600; color:var(--txt2); margin-bottom:8px; padding:4px 0; border-bottom:1px solid var(--bdr); }
        
        /* Clickable odds */
        .odds-value.clickable { cursor:pointer; transition:transform 0.1s, box-shadow 0.1s; }
        .odds-value.clickable:hover { transform:scale(1.05); box-shadow:0 0 0 2px var(--accent); }
        
        /* Bet Slip Popup */
        .bet-slip-overlay { position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:1000; display:flex; align-items:center; justify-content:center; opacity:0; visibility:hidden; transition:all 0.2s; }
        .bet-slip-overlay.active { opacity:1; visibility:visible; }
        .bet-slip { background:var(--bg2); border:1px solid var(--bdr); border-radius:12px; width:90%; max-width:400px; overflow:hidden; transform:scale(0.9); transition:transform 0.2s; }
        .bet-slip-overlay.active .bet-slip { transform:scale(1); }
        .bet-slip-header { background:var(--bg3); padding:12px 16px; display:flex; justify-content:space-between; align-items:center; border-bottom:1px solid var(--bdr); }
        .bet-slip-title { font-weight:600; font-size:14px; }
        .bet-slip-close { background:none; border:none; color:var(--txt3); font-size:20px; cursor:pointer; padding:0; line-height:1; }
        .bet-slip-close:hover { color:var(--txt); }
        .bet-slip-body { padding:16px; }
        .bet-slip-game { display:flex; align-items:center; gap:8px; margin-bottom:12px; padding-bottom:12px; border-bottom:1px solid var(--bdr); }
        .bet-slip-teams { font-weight:500; }
        .bet-slip-period { font-size:12px; color:var(--txt3); }
        .bet-slip-selection { background:var(--bg3); border-radius:8px; padding:12px; margin-bottom:16px; }
        .bet-slip-side { font-size:18px; font-weight:600; color:var(--accent); }
        .bet-slip-details { display:flex; gap:16px; margin-top:8px; font-size:13px; color:var(--txt2); }
        .bet-slip-book { display:flex; align-items:center; gap:6px; }
        .bet-slip-book .book-logo { width:24px; height:16px; font-size:7px; }
        .bet-slip-field { margin-bottom:12px; }
        .bet-slip-field label { display:block; font-size:11px; color:var(--txt3); text-transform:uppercase; margin-bottom:4px; }
        .bet-slip-field input, .bet-slip-field select { width:100%; padding:10px 12px; background:var(--bg); border:1px solid var(--bdr); border-radius:6px; color:var(--txt); font-size:14px; font-family:inherit; box-sizing:border-box; }
        .bet-slip-field input:focus, .bet-slip-field select:focus { outline:none; border-color:var(--accent); }
        .bet-slip-row { display:flex; gap:12px; }
        .bet-slip-row .bet-slip-field { margin-bottom:12px; }
        .book-input-row { display:flex; gap:8px; }
        .book-input-row select { flex:1; }
        .book-input-row input { flex:1; }
        .save-default-row { margin-top:6px; }
        .save-default-label { display:flex; align-items:center; gap:6px; font-size:12px; color:var(--txt2); cursor:pointer; }
        .save-default-label input { width:14px; height:14px; accent-color:var(--accent); }
        .bet-slip-ev { display:flex; justify-content:space-between; padding:8px 12px; background:var(--profit-bg); border-radius:6px; margin-bottom:16px; }
        .bet-slip-ev-label { font-size:11px; color:var(--profit); }
        .bet-slip-ev-value { font-weight:600; color:var(--profit); }
        .bet-slip-actions { display:flex; gap:8px; }
        .bet-slip-actions .btn { flex:1; padding:12px; font-size:14px; }
        
        /* Bet Log Tab */
        .tabs-row { display:flex; align-items:flex-start; gap:12px; margin-bottom:12px; }
        .tabs-container { display:flex; gap:4px; flex-shrink:0; }
        .tab-btn { padding:8px 16px; background:var(--bg2); border:1px solid var(--bdr); border-radius:6px; color:var(--txt3); font-family:inherit; font-size:12px; font-weight:500; cursor:pointer; }
        .tab-btn.active { background:var(--accent); color:white; border-color:var(--accent); }
        .tab-btn:hover:not(.active) { color:var(--txt2); background:var(--bg3); }
        .tab-content { display:none; }
        .tab-content.active { display:block; }
        
        .bet-log { max-height:400px; overflow-y:auto; }
        .bet-log-empty { text-align:center; padding:24px; color:var(--txt3); }
        .bet-log-table { width:100%; border-collapse:collapse; font-size:12px; }
        .bet-log-table th { padding:8px 6px; text-align:left; font-size:10px; font-weight:600; color:var(--txt3); text-transform:uppercase; border-bottom:1px solid var(--bdr); position:sticky; top:0; background:var(--bg3); }
        .bet-log-table td { padding:8px 6px; border-bottom:1px solid var(--bdr); }
        .bet-log-table tr:hover { background:rgba(255,255,255,0.02); }
        .bet-log-actions { display:flex; gap:8px; margin-bottom:12px; flex-wrap:wrap; }
        .bet-log-actions .btn { font-size:11px; padding:8px 10px; }
        .bet-result { padding:2px 6px; border-radius:3px; font-size:10px; font-weight:600; }
        .bet-result.pending { background:var(--bg); color:var(--txt3); }
        .bet-result.win { background:var(--profit-bg); color:var(--profit); }
        .bet-result.loss { background:var(--loss-bg); color:var(--loss); }
        .bet-result.push { background:rgba(59,130,246,0.1); color:var(--accent); }
        .bet-delete { background:none; border:none; color:var(--txt3); cursor:pointer; font-size:14px; padding:2px; }
        .bet-delete:hover { color:var(--loss); }
        .bet-checkbox { width:16px; height:16px; cursor:pointer; accent-color:var(--accent); }
        .bet-log-table th:first-child, .bet-log-table td:first-child { width:30px; text-align:center; }
        
        /* Responsive */
        @media (max-width: 900px) {
            .config-grid { grid-template-columns:repeat(2, 1fr); }
            .book-section { grid-column: span 2; }
            .stats { flex-wrap:wrap; }
            .stat { min-width:calc(50% - 6px); }
        }
        
        /* Mobile Mode - Compact but readable */
        .mobile-mode .app { padding:6px; }
        .mobile-mode .header { padding:6px 0 10px; flex-direction:column; gap:8px; }
        .mobile-mode .logo { gap:6px; }
        .mobile-mode .logo-icon { font-size:20px; }
        .mobile-mode .logo h1 { font-size:15px; }
        .mobile-mode .controls { width:100%; justify-content:center; gap:4px; flex-wrap:wrap; }
        .mobile-mode .controls .btn { padding:6px 10px; font-size:12px; }
        .mobile-mode .status { padding:5px 8px; font-size:11px; gap:4px; }
        .mobile-mode .status .dot { width:6px; height:6px; }
        
        .mobile-mode .stats { gap:4px; margin-bottom:10px; }
        .mobile-mode .stat { padding:8px 10px; min-width:calc(25% - 3px); flex:1; border-radius:6px; }
        .mobile-mode .stat-label { font-size:9px; margin-bottom:2px; }
        .mobile-mode .stat-value { font-size:14px; }
        
        .mobile-mode .games { gap:6px; grid-template-columns:1fr; }
        .mobile-mode .game { border-radius:6px; }
        .mobile-mode .game-header { padding:10px 12px; }
        .mobile-mode .matchup { gap:8px; }
        .mobile-mode .team { gap:1px; }
        .mobile-mode .team-name { font-size:9px; }
        .mobile-mode .team-score { font-size:18px; margin-left:5px; }
        .mobile-mode .team-abbr { font-size:12px; }
        .mobile-mode .vs { font-size:11px; }
        .mobile-mode .game-status { padding:4px 8px; font-size:10px; }
        .mobile-mode .game-status.live .live-dot { width:5px; height:5px; }
        .mobile-mode .game-time { font-size:12px; }
        .mobile-mode .game-time-tz { font-size:8px; }
        .mobile-mode .game-clock { font-size:10px; }
        .mobile-mode .game-date { font-size:10px; }
        
        .mobile-mode .period-tabs { padding:5px 10px; gap:3px; }
        .mobile-mode .period-tab { padding:5px 10px; font-size:11px; }
        
        .mobile-mode .odds-section { padding:10px; }
        .mobile-mode .odds-header { margin-bottom:8px; flex-direction:column; gap:6px; align-items:stretch; }
        .mobile-mode .odds-title { font-size:12px; }
        .mobile-mode .consensus-pills { gap:16px; justify-content:space-between; }
        .mobile-mode .pill-group { gap:8px; }
        .mobile-mode .pill-label { font-size:9px; }
        .mobile-mode .pill-value { font-size:12px; }
        
        /* Mobile table - compact but readable */
        .mobile-mode .table-scroll { overflow-x:visible; }
        .mobile-mode .odds-table { min-width:auto; width:100%; table-layout:fixed; }
        .mobile-mode .odds-table th { padding:5px 2px; font-size:9px; text-align:center; }
        .mobile-mode .odds-table th:first-child { text-align:left; width:50px; }
        .mobile-mode .odds-table td { padding:6px 2px; text-align:center; font-size:11px; }
        .mobile-mode .odds-table td:first-child { text-align:left; }
        
        .mobile-mode .book-cell { gap:0; justify-content:flex-start; }
        .mobile-mode .book-logo { width:30px; height:22px; font-size:8px; border-radius:3px; font-weight:700; }
        .mobile-mode .book-name { display:none; }
        .mobile-mode .book-badge { display:none; }
        
        .mobile-mode .odds-value { padding:3px 4px; min-width:auto; font-size:11px; border-radius:3px; }
        .mobile-mode .ev-value { padding:3px 4px; min-width:auto; font-size:11px; border-radius:3px; }
        .mobile-mode .edge-badge { padding:3px 5px; font-size:10px; border-radius:3px; }
        .mobile-mode .signal-cell { font-size:10px; }
        
        .mobile-mode .consensus-row td:first-child { font-size:10px; }
        .mobile-mode .consensus-row td:first-child span { font-size:10px !important; }
        
        /* Hide Line column on mobile */
        .mobile-mode .odds-table th:nth-child(2),
        .mobile-mode .odds-table td:nth-child(2) { display:none; }
        
        /* Config mobile */
        .mobile-mode .config { padding:10px; }
        .mobile-mode .config-grid { grid-template-columns:1fr 1fr; gap:8px; }
        .mobile-mode .config-title { font-size:12px; }
        .mobile-mode .field label { font-size:9px; }
        .mobile-mode .field input, .mobile-mode .field select { padding:6px 8px; font-size:11px; }
        .mobile-mode .book-section { grid-column: span 2; }
        .mobile-mode .book-selector { gap:3px; }
        .mobile-mode .book-tag { padding:3px 6px; font-size:10px; }
        
        /* Alerts mobile */
        .mobile-mode .tabs-row { flex-direction:column; gap:8px; }
        .mobile-mode .alerts-inline { width:100%; }
        .mobile-mode .alert { padding:8px 10px; border-radius:4px; max-width:100%; flex:1; }
        .mobile-mode .alert-title { font-size:11px; }
        .mobile-mode .alert-time { font-size:9px; }
        .mobile-mode .alert-body { font-size:11px; }
        .mobile-mode .alert-ev { font-size:10px; padding:2px 5px; margin-left:4px; }
        
        .mobile-mode #mobileToggle { background:var(--accent); color:white; }
        
        /* Debug mobile */
        .mobile-mode .debug { font-size:9px; padding:8px; max-height:120px; }
        
        /* Collapsed mobile */
        .mobile-mode .collapsed-summary { padding:8px 10px; gap:6px; }
        .mobile-mode .collapsed-summary .cs-item { padding:3px 6px; }
        .mobile-mode .collapsed-summary .cs-label { font-size:9px; }
        .mobile-mode .collapsed-summary .cs-value { font-size:11px; }
        .mobile-mode .pin-btn { font-size:12px; padding:2px; }
        .mobile-mode .expand-btn { font-size:10px; padding:2px 4px; }
        .mobile-mode .best-bets-bar { padding:6px 10px; gap:4px; }
        .mobile-mode .best-bets-label { font-size:9px; }
        .mobile-mode .best-bet-chip { padding:3px 6px; font-size:10px; }
    </style>
</head>
<body>
<div class="app">
    <header class="header">
        <div class="logo">
            <span class="logo-icon">üèÄ</span>
            <h1>CBB</h1>
        </div>
        <div class="controls">
            <div class="status"><div class="dot off" id="dot"></div><span id="statusTxt">Disconnected</span></div>
            <button class="btn btn-secondary" id="collapseAllBtn" onclick="toggleCollapseAll()">‚ñº Collapse</button>
            <button class="btn btn-secondary" id="mobileToggle" onclick="toggleMobile()">üì±</button>
            <button class="btn btn-secondary" onclick="toggleConfig()">Settings</button>
            <button class="btn btn-primary" onclick="fetchData()">Refresh</button>
            <button class="btn btn-secondary" onclick="loadDemo()">Demo</button>
        </div>
    </header>
    
    <div class="config" id="config">
        <div class="config-header">
            <span class="config-title">Settings</span>
        </div>
        <div class="config-grid">
            <div class="field">
                <label>API Key</label>
                <input type="password" id="apiKey" placeholder="SportsGameOdds API Key">
            </div>
            <div class="field">
                <label>Min EV %</label>
                <input type="number" id="minEV" value="2" min="0" max="20" step="0.5">
            </div>
            <div class="field">
                <label>Devig Method</label>
                <select id="devigMethod">
                    <option value="additive">Additive (Basic)</option>
                    <option value="multiplicative">Multiplicative (Power)</option>
                    <option value="shin">Shin</option>
                    <option value="worstcase">Worst Case</option>
                </select>
            </div>
            <div class="field">
                <label>Refresh (sec)</label>
                <input type="number" id="refreshInt" value="30" min="10">
            </div>
            <div class="field">
                <label>Sound Alerts</label>
                <select id="alertSound">
                    <option value="on">Enabled</option>
                    <option value="off">Disabled</option>
                </select>
            </div>
            <div class="field">
                <label>Auto-Send to Sheet</label>
                <select id="webhookEnabled">
                    <option value="on">Enabled</option>
                    <option value="off">Disabled</option>
                </select>
            </div>
            <div class="field" style="grid-column: span 2">
                <label>Webhook URL</label>
                <input type="text" id="webhookUrl" placeholder="https://script.google.com/macros/s/...">
            </div>
            <div class="field">
                <label>Telegram Alerts</label>
                <select id="telegramEnabled">
                    <option value="on">Enabled</option>
                    <option value="off">Disabled</option>
                </select>
            </div>
            <div class="field">
                <label>Telegram Min EV %</label>
                <input type="number" id="telegramMinEV" value="5" min="0" max="50" step="0.5">
            </div>
            <div class="field">
                <label>Telegram Bot Token</label>
                <input type="text" id="telegramToken" placeholder="123456:ABC...">
            </div>
            <div class="field">
                <label>Telegram Chat ID</label>
                <input type="text" id="telegramChatId" placeholder="1234567890">
            </div>
            <div class="field book-section">
                <label>Sharp Books (Fair Value Source)</label>
                <div class="book-selector" id="sharpSelector"></div>
            </div>
            <div class="field book-section">
                <label>Compare Books (Check for +EV)</label>
                <div class="book-selector" id="compareSelector"></div>
            </div>
            <div class="field" style="grid-column: span 4; border-top: 1px solid var(--bdr); padding-top: 12px; margin-top: 8px;">
                <label style="font-size:12px; color:var(--txt2);">üö® Steam Move Alerts</label>
            </div>
            <div class="field">
                <label>Steam Alerts</label>
                <select id="steamEnabled">
                    <option value="on">Enabled</option>
                    <option value="off">Disabled</option>
                </select>
            </div>
            <div class="field">
                <label>Spread Move (pts)</label>
                <input type="number" id="steamSpreadMove" value="1.0" min="0.5" max="5" step="0.5">
            </div>
            <div class="field">
                <label>Total Move (pts)</label>
                <input type="number" id="steamTotalMove" value="1.5" min="0.5" max="10" step="0.5">
            </div>
            <div class="field">
                <label>Time Window (min)</label>
                <input type="number" id="steamTimeWindow" value="3" min="1" max="30" step="1">
            </div>
            <div class="field" style="grid-column: span 4; border-top: 1px solid var(--bdr); padding-top: 12px; margin-top: 8px;">
                <label style="font-size:12px; color:var(--txt2);">üí∞ Arbitrage Alerts</label>
            </div>
            <div class="field">
                <label>Arb Alerts</label>
                <select id="arbEnabled">
                    <option value="on">Enabled</option>
                    <option value="off">Disabled</option>
                </select>
            </div>
            <div class="field">
                <label>Min Arb %</label>
                <input type="number" id="minArb" value="0.5" min="0" max="10" step="0.1">
            </div>
            <div class="field">
                <label>Arb Telegram</label>
                <select id="arbTelegramEnabled">
                    <option value="off">Disabled</option>
                    <option value="on">Enabled</option>
                </select>
            </div>
        </div>
    </div>
    
    <div class="stats">
        <div class="stat"><div class="stat-label">Games</div><div class="stat-value blue" id="sGames">0</div></div>
        <div class="stat"><div class="stat-label">+EV Opps</div><div class="stat-value green" id="sEV">0</div></div>
        <div class="stat"><div class="stat-label">Best Edge</div><div class="stat-value green" id="sBest">--</div></div>
        <div class="stat"><div class="stat-label">Arbs</div><div class="stat-value" id="sArbs" style="color:var(--warn)">0</div></div>
        <div class="stat"><div class="stat-label">Updated</div><div class="stat-value" id="sTime" style="font-size:14px">--</div></div>
    </div>
    
    <div class="tabs-row">
        <div class="tabs-container">
            <button class="tab-btn active" onclick="switchTab('games')">Games</button>
            <button class="tab-btn" onclick="switchTab('betlog')">Bet Log</button>
        </div>
        <div class="alerts-inline" id="alerts"></div>
    </div>
    
    <div class="tab-content active" id="tab-games">
        <div class="games" id="games">
            <div class="loading"><div class="spinner"></div><div style="color:var(--txt3)">Enter API key and refresh, or click Demo</div></div>
        </div>
    </div>
    
    <div class="tab-content" id="tab-betlog">
        <div class="bet-log-actions">
            <button class="btn btn-primary" onclick="copyAllBets()">üìã Copy All</button>
            <button class="btn btn-secondary" onclick="copySelectedBets()">üìã Copy Selected</button>
            <button class="btn btn-secondary" onclick="exportBetsCSV()">üì• Export CSV</button>
            <button class="btn btn-secondary" onclick="clearSelectedBets()">üóëÔ∏è Clear Selected</button>
            <button class="btn btn-secondary" onclick="clearBets()">üóëÔ∏è Clear All</button>
        </div>
        <div class="bet-log" id="betLog">
            <div class="bet-log-empty">No bets logged yet. Click on any odds to log a bet.</div>
        </div>
    </div>
    
    <div class="debug" id="debug"><pre id="log"></pre></div>
</div>

<!-- Bet Slip Popup -->
<div class="bet-slip-overlay" id="betSlipOverlay" onclick="closeBetSlip(event)">
    <div class="bet-slip" onclick="event.stopPropagation()">
        <div class="bet-slip-header">
            <span class="bet-slip-title">Log Bet</span>
            <button class="bet-slip-close" onclick="closeBetSlip()">&times;</button>
        </div>
        <div class="bet-slip-body">
            <div class="bet-slip-field">
                <label>Date</label>
                <input type="text" id="bsDate" placeholder="1/14/2026">
            </div>
            <div class="bet-slip-field">
                <label>Market</label>
                <input type="text" id="bsMarket" placeholder="VGK @ LAK P1 OVER 1.5">
            </div>
            <div class="bet-slip-row">
                <div class="bet-slip-field" style="flex:1">
                    <label>Prop #</label>
                    <input type="text" id="bsPropNum" placeholder="Optional">
                </div>
                <div class="bet-slip-field" style="flex:1">
                    <label>Juice (Odds)</label>
                    <input type="number" id="bsJuice" placeholder="-110">
                </div>
            </div>
            <div class="bet-slip-row">
                <div class="bet-slip-field" style="flex:1">
                    <label>Risk ($)</label>
                    <input type="number" id="bsRisk" placeholder="100" min="1" step="1">
                </div>
                <div class="bet-slip-field" style="flex:1">
                    <label>To Win ($)</label>
                    <input type="number" id="bsToWin" placeholder="Auto-calculated" step="0.01">
                </div>
            </div>
            <div class="bet-slip-field">
                <label>Book</label>
                <div class="book-input-row">
                    <select id="bsBook" onchange="onBookSelect()">
                        <option value="">Select Book</option>
                        <option value="draftkings">DraftKings</option>
                        <option value="fanduel">FanDuel</option>
                        <option value="betmgm">BetMGM</option>
                        <option value="caesars">Caesars</option>
                        <option value="pointsbet">PointsBet</option>
                        <option value="betrivers">BetRivers</option>
                        <option value="bet365">Bet365</option>
                        <option value="espnbet">ESPN Bet</option>
                        <option value="fanatics">Fanatics</option>
                        <option value="pinnacle">Pinnacle</option>
                        <option value="circa">Circa</option>
                        <option value="bookmaker">Bookmaker</option>
                        <option value="betcris">BetCRIS</option>
                        <option value="betonline">BetOnline</option>
                        <option value="_custom">-- Custom --</option>
                    </select>
                    <input type="text" id="bsBookCustom" placeholder="Custom book name" style="display:none">
                </div>
                <div class="save-default-row" id="saveDefaultRow" style="display:none">
                    <label class="save-default-label">
                        <input type="checkbox" id="bsSaveDefault"> Save as default for <span id="bsOriginalBook">--</span>
                    </label>
                </div>
            </div>
            <div class="bet-slip-ev" id="bsEV" style="display:none">
                <span class="bet-slip-ev-label">Expected Value</span>
                <span class="bet-slip-ev-value" id="bsEVValue">+0.0%</span>
            </div>
            <div class="bet-slip-actions">
                <button class="btn btn-secondary" onclick="closeBetSlip()">Cancel</button>
                <button class="btn btn-primary" onclick="submitBet()">Log Bet</button>
            </div>
        </div>
    </div>
</div>

<script>
const CFG = {
    apiKey: '',
    minEV: 2,
    devigMethod: 'additive',
    refresh: 30,
    sound: true,
    webhookEnabled: true,
    webhookUrl: 'https://script.google.com/macros/s/AKfycbzd8TSUQvLubGQZX3oWIrsu6mx6TNiEFEmmOvfBMOHZ3EySOogJKPKqKhPJaJeR9b8/exec',
    telegramEnabled: false,
    telegramToken: '8397486568:AAH2bJH09qFbjPuH6bJH09qFbjPuH6r6gM7Brqcyce7WV3eE',
    telegramChatId: '1567501072',
    telegramMinEV: 5,
    sharpBooks: ['pinnacle', 'circa', 'bookmaker'],
    compareBooks: ['draftkings', 'fanduel', 'betmgm', 'caesars'],
    // Steam alert settings
    steamEnabled: true,
    steamSpreadMove: 1.0,
    steamTotalMove: 1.5,
    steamTimeWindow: 3,
    // Arbitrage settings
    arbEnabled: true,
    minArb: 0.5,
    arbTelegramEnabled: false
};

const BOOKS = {
    pinnacle: {n:'Pinnacle', a:'PIN', c:'#c41230'},
    circa: {n:'Circa', a:'CCA', c:'#d4af37'},
    bookmaker: {n:'Bookmaker', a:'BKM', c:'#1a4d1a'},
    betcris: {n:'BetCRIS', a:'CRS', c:'#003366'},
    betonline: {n:'BetOnline', a:'BOL', c:'#8b0000'},
    draftkings: {n:'DraftKings', a:'DK', c:'#53d337'},
    fanduel: {n:'FanDuel', a:'FD', c:'#1493ff'},
    betmgm: {n:'BetMGM', a:'MGM', c:'#c9a227'},
    caesars: {n:'Caesars', a:'CZR', c:'#0d4524'},
    pointsbet: {n:'PointsBet', a:'PB', c:'#e44c23'},
    betrivers: {n:'BetRivers', a:'BR', c:'#1275ba'},
    bet365: {n:'Bet365', a:'365', c:'#027b5b'},
    espnbet: {n:'ESPN Bet', a:'ESPN', c:'#d00'},
    fanatics: {n:'Fanatics', a:'FAN', c:'#004687'}
};

const SHARP_LIST = ['pinnacle','circa','bookmaker','betcris','betonline'];
const SOFT_LIST = ['draftkings','fanduel','betmgm','caesars','pointsbet','betrivers','bet365','espnbet','fanatics'];

let DATA = [], alerted = new Set(), timer = null, mobileMode = false;
let lineHistory = {}; // Track line changes: {eventId-bookId-period-side: {price, timestamp}}
let consensusHistory = {}; // Track consensus/sharp line changes for steam alerts: {eventId-period-type: [{line, timestamp}]}
let steamAlerted = new Set(); // Track steam alerts to avoid duplicates
let betLog = []; // Array of logged bets
let currentBetSlip = null; // Current bet being created
let bookAliases = {}; // Map of bookKey -> custom display name

function log(m) { document.getElementById('log').textContent += `${new Date().toLocaleTimeString()} ${m}\n`; console.log(m); }

// Dismiss alert by removing it from the DOM
function dismissAlert(id) {
    const el = document.getElementById(id);
    if (el) el.remove();
}

// Tab switching
function switchTab(tab) {
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    document.querySelector(`.tab-btn[onclick="switchTab('${tab}')"]`).classList.add('active');
    document.getElementById('tab-' + tab).classList.add('active');
    if (tab === 'betlog') renderBetLog();
}

// Bet Slip functions
function openBetSlip(gameId, bookKey, period, side, line, odds, ev) {
    const game = DATA.find(d => d.game.eventID === gameId)?.game;
    if (!game) return;
    
    const bkd = BOOKS[bookKey] || {n: bookKey, a: bookKey.substring(0,3).toUpperCase(), c: '#666'};
    const away = game.teams?.away?.names?.short || game.teams?.away?.name || 'Away';
    const home = game.teams?.home?.names?.short || game.teams?.home?.name || 'Home';
    
    currentBetSlip = { gameId, bookKey, period, side, line, odds, ev, away, home, timestamp: Date.now(), originalBookKey: bookKey };
    
    // Populate editable fields
    document.getElementById('bsDate').value = new Date().toLocaleDateString('en-US');
    document.getElementById('bsMarket').value = `${away} @ ${home} P${period.replace('p','')} ${side.toUpperCase()} ${line}`;
    document.getElementById('bsPropNum').value = '';
    document.getElementById('bsJuice').value = odds;
    document.getElementById('bsRisk').value = '';
    document.getElementById('bsToWin').value = '';
    
    // Check if there's a saved alias for this book
    const savedAlias = bookAliases[bookKey];
    if (savedAlias) {
        document.getElementById('bsBook').value = '_custom';
        document.getElementById('bsBookCustom').value = savedAlias;
        document.getElementById('bsBookCustom').style.display = 'block';
    } else {
        document.getElementById('bsBook').value = bookKey;
        document.getElementById('bsBookCustom').value = '';
        document.getElementById('bsBookCustom').style.display = 'none';
    }
    
    // Show save default option
    document.getElementById('saveDefaultRow').style.display = 'flex';
    document.getElementById('bsOriginalBook').textContent = bkd.n;
    document.getElementById('bsSaveDefault').checked = false;
    
    if (ev !== null) {
        document.getElementById('bsEV').style.display = 'flex';
        document.getElementById('bsEVValue').textContent = `${ev > 0 ? '+' : ''}${ev.toFixed(1)}%`;
    } else {
        document.getElementById('bsEV').style.display = 'none';
    }
    
    document.getElementById('betSlipOverlay').classList.add('active');
    document.getElementById('bsRisk').focus();
    
    // Auto-calculate To Win when Risk or Juice changes
    document.getElementById('bsRisk').oninput = calcToWin;
    document.getElementById('bsJuice').oninput = calcToWin;
}

function onBookSelect() {
    const select = document.getElementById('bsBook');
    const customInput = document.getElementById('bsBookCustom');
    if (select.value === '_custom') {
        customInput.style.display = 'block';
        customInput.focus();
    } else {
        customInput.style.display = 'none';
        customInput.value = '';
    }
}

function calcToWin() {
    const risk = parseFloat(document.getElementById('bsRisk').value);
    const juice = parseInt(document.getElementById('bsJuice').value);
    if (risk && juice) {
        const toWin = juice >= 100 ? risk * (juice / 100) : risk * (100 / Math.abs(juice));
        document.getElementById('bsToWin').value = toWin.toFixed(2);
    }
}

function closeBetSlip(event) {
    if (event && event.target !== event.currentTarget) return;
    document.getElementById('betSlipOverlay').classList.remove('active');
    currentBetSlip = null;
}

function getBookNameForBet() {
    const select = document.getElementById('bsBook');
    const customInput = document.getElementById('bsBookCustom');
    
    if (select.value === '_custom' || customInput.style.display !== 'none') {
        return customInput.value.trim() || 'Custom';
    }
    
    const bkd = BOOKS[select.value];
    return bkd ? bkd.n : select.value || 'Unknown';
}

function submitBet() {
    const risk = parseFloat(document.getElementById('bsRisk').value);
    if (!risk || risk <= 0) {
        alert('Please enter a valid risk amount');
        return;
    }
    
    const juice = parseInt(document.getElementById('bsJuice').value);
    if (!juice) {
        alert('Please enter valid odds/juice');
        return;
    }
    
    // Get To Win - use entered value or calculate
    let toWin = parseFloat(document.getElementById('bsToWin').value);
    if (!toWin) {
        toWin = juice >= 100 ? risk * (juice / 100) : risk * (100 / Math.abs(juice));
    }
    
    const bookName = getBookNameForBet();
    const bookKey = document.getElementById('bsBook').value;
    
    // Save as default if checked
    if (document.getElementById('bsSaveDefault').checked && currentBetSlip?.originalBookKey) {
        const customName = document.getElementById('bsBookCustom').value.trim();
        if (customName || bookKey !== currentBetSlip.originalBookKey) {
            bookAliases[currentBetSlip.originalBookKey] = customName || bookName;
            saveBookAliases();
        }
    }
    
    const bet = {
        id: Date.now(),
        date: document.getElementById('bsDate').value || new Date().toLocaleDateString('en-US'),
        market: document.getElementById('bsMarket').value || '',
        propNum: document.getElementById('bsPropNum').value || '',
        juice: juice,
        risk: risk,
        book: bookKey === '_custom' ? '_custom' : bookKey,
        bookName: bookName, // Store the display name
        toWin: toWin,
        ev: currentBetSlip?.ev || null,
        result: 'pending',
        timestamp: new Date().toISOString()
    };
    
    betLog.push(bet);
    saveBetLog();
    
    // Send to webhook if enabled
    if (CFG.webhookEnabled && CFG.webhookUrl) {
        sendToWebhook(bet);
    }
    
    closeBetSlip();
    
    // Show confirmation
    triggerAlert({teams: {away: {names: {short: 'Bet'}}, home: {names: {short: 'Logged'}}}}, {n: bookName}, {line: ''}, bet.ev, null, true, false, true);
}

async function sendToWebhook(bet) {
    try {
        const payload = {
            type: 'bet',
            date: bet.date,
            market: bet.market,
            propNum: bet.propNum || '',
            juice: bet.juice,
            risk: '$' + bet.risk.toFixed(2),
            book: bet.bookName || BOOKS[bet.book]?.n || bet.book || 'Unknown',
            toWin: '$' + bet.toWin.toFixed(2)
        };
        
        const response = await fetch(CFG.webhookUrl, {
            method: 'POST',
            mode: 'no-cors', // Required for Google Apps Script
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
        });
        
        console.log('Webhook sent:', payload);
        
        // Show success notification
        const c = document.getElementById('alerts');
        const id = 'wh' + Date.now();
        c.insertAdjacentHTML('afterbegin', `<div class="alert" id="${id}" onclick="dismissAlert('${id}')" style="border-color:#22c55e">
            <div class="alert-header"><span class="alert-title">üì§ Sent to Sheet</span></div>
        </div>`);
        setTimeout(() => dismissAlert(id), 2000);
        
    } catch(err) {
        console.error('Webhook error:', err);
        const c = document.getElementById('alerts');
        const id = 'whe' + Date.now();
        c.insertAdjacentHTML('afterbegin', `<div class="alert" id="${id}" onclick="dismissAlert('${id}')" style="border-color:var(--loss)">
            <div class="alert-header"><span class="alert-title">‚ö†Ô∏è Webhook Failed</span></div>
            <div class="alert-body">${err.message}</div>
        </div>`);
        setTimeout(() => dismissAlert(id), 5000);
    }
}

let telegramSent = new Set(); // Track sent Telegram alerts to avoid duplicates

async function sendTelegram(game, book, line, side, odds, ev) {
    if (!CFG.telegramEnabled || !CFG.telegramToken || !CFG.telegramChatId) return;
    if (ev < CFG.telegramMinEV) return;
    
    // Create unique key to avoid duplicate alerts
    const key = `${game.eventID}-${book}-${line}-${side}`;
    if (telegramSent.has(key)) return;
    telegramSent.add(key);
    
    const t = game.teams || {};
    const away = t.away?.names?.short || t.away?.names?.abbr || 'Away';
    const home = t.home?.names?.short || t.home?.names?.abbr || 'Home';
    
    const message = `üèí *NHL +EV Alert*
    
*${away} @ ${home}*
üìä ${side.toUpperCase()} ${line}
üìï ${book}
üí∞ Odds: ${odds > 0 ? '+' : ''}${odds}
‚úÖ *EV: +${ev.toFixed(1)}%*`;

    try {
        await fetch(`https://api.telegram.org/bot${CFG.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: CFG.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        console.log('Telegram sent:', key);
    } catch(err) {
        console.error('Telegram error:', err);
    }
}

function saveBookAliases() {
    localStorage.setItem('ppBookAliases', JSON.stringify(bookAliases));
}

function loadBookAliases() {
    const saved = localStorage.getItem('ppBookAliases');
    if (saved) bookAliases = JSON.parse(saved);
}

function saveBetLog() {
    localStorage.setItem('ppBetLog', JSON.stringify(betLog));
}

function loadBetLog() {
    const saved = localStorage.getItem('ppBetLog');
    if (saved) betLog = JSON.parse(saved);
}

function renderBetLog() {
    const container = document.getElementById('betLog');
    if (!betLog.length) {
        container.innerHTML = '<div class="bet-log-empty">No bets logged yet. Click on any odds to log a bet.</div>';
        return;
    }
    
    // Sort by timestamp descending (newest first)
    const sorted = [...betLog].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    container.innerHTML = `<table class="bet-log-table">
        <thead>
            <tr>
                <th><input type="checkbox" class="bet-checkbox" id="selectAllBets" onchange="toggleAllBets(this.checked)"></th>
                <th>Date</th>
                <th>Market</th>
                <th>Prop #</th>
                <th>Juice</th>
                <th>Risk</th>
                <th>Book</th>
                <th>To Win</th>
                <th>Result</th>
            </tr>
        </thead>
        <tbody>
            ${sorted.map(bet => {
                // Use bookName if available, otherwise fall back to BOOKS lookup
                const displayName = bet.bookName || (BOOKS[bet.book] ? BOOKS[bet.book].n : bet.book || 'Unknown');
                const bkd = BOOKS[bet.book] || {a: displayName.substring(0,3).toUpperCase(), c: '#666'};
                return `<tr>
                    <td><input type="checkbox" class="bet-checkbox" data-bet-id="${bet.id}"></td>
                    <td>${bet.date}</td>
                    <td style="max-width:180px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap" title="${bet.market}">${bet.market}</td>
                    <td>${bet.propNum || ''}</td>
                    <td>${bet.juice > 0 ? '+' : ''}${bet.juice}</td>
                    <td>$${bet.risk.toFixed(2)}</td>
                    <td title="${displayName}"><span class="book-logo" style="background:${bkd.c};color:#fff;padding:2px 4px;border-radius:2px;font-size:8px">${bkd.a}</span></td>
                    <td>$${bet.toWin.toFixed(2)}</td>
                    <td>
                        <select class="bet-result ${bet.result}" onchange="updateBetResult(${bet.id}, this.value)" style="background:transparent;border:none;color:inherit;font-size:11px;cursor:pointer">
                            <option value="pending" ${bet.result === 'pending' ? 'selected' : ''}>Pending</option>
                            <option value="win" ${bet.result === 'win' ? 'selected' : ''}>Win</option>
                            <option value="loss" ${bet.result === 'loss' ? 'selected' : ''}>Loss</option>
                            <option value="push" ${bet.result === 'push' ? 'selected' : ''}>Push</option>
                        </select>
                    </td>
                </tr>`;
            }).join('')}
        </tbody>
    </table>`;
}

function toggleAllBets(checked) {
    document.querySelectorAll('.bet-checkbox[data-bet-id]').forEach(cb => cb.checked = checked);
}

function getSelectedBetIds() {
    return Array.from(document.querySelectorAll('.bet-checkbox[data-bet-id]:checked')).map(cb => parseInt(cb.dataset.betId));
}

function betsToClipboardText(bets) {
    // Tab-separated format for pasting into sheets: Date, Market, Prop #, Juice, Risk, Book, To Win
    return bets.map(bet => {
        // Use bookName if available, otherwise fall back to BOOKS lookup
        const displayName = bet.bookName || (BOOKS[bet.book] ? BOOKS[bet.book].n : bet.book || 'Unknown');
        return [
            bet.date,
            bet.market,
            bet.propNum || '',
            bet.juice,
            `$${bet.risk.toFixed(2)}`,
            displayName,
            `$${bet.toWin.toFixed(2)}`
        ].join('\t');
    }).join('\n');
}

function copyAllBets() {
    if (!betLog.length) {
        alert('No bets to copy');
        return;
    }
    const text = betsToClipboardText(betLog);
    navigator.clipboard.writeText(text).then(() => {
        showCopyConfirmation(betLog.length);
    }).catch(err => {
        alert('Failed to copy: ' + err);
    });
}

function copySelectedBets() {
    const selectedIds = getSelectedBetIds();
    if (!selectedIds.length) {
        alert('No bets selected. Use checkboxes to select bets.');
        return;
    }
    const selectedBets = betLog.filter(b => selectedIds.includes(b.id));
    const text = betsToClipboardText(selectedBets);
    navigator.clipboard.writeText(text).then(() => {
        showCopyConfirmation(selectedBets.length);
    }).catch(err => {
        alert('Failed to copy: ' + err);
    });
}

function showCopyConfirmation(count) {
    const c = document.getElementById('alerts');
    const id = 'copy' + Date.now();
    c.insertAdjacentHTML('afterbegin', `<div class="alert" id="${id}" onclick="dismissAlert('${id}')" style="border-color:var(--accent)">
        <div class="alert-header"><span class="alert-title">üìã Copied!</span></div>
        <div class="alert-body">${count} bet${count > 1 ? 's' : ''} copied to clipboard</div>
    </div>`);
    setTimeout(() => dismissAlert(id), 3000);
}

function clearSelectedBets() {
    const selectedIds = getSelectedBetIds();
    if (!selectedIds.length) {
        alert('No bets selected. Use checkboxes to select bets.');
        return;
    }
    if (confirm(`Delete ${selectedIds.length} selected bet${selectedIds.length > 1 ? 's' : ''}?`)) {
        betLog = betLog.filter(b => !selectedIds.includes(b.id));
        saveBetLog();
        renderBetLog();
    }
}

function updateBetResult(betId, result) {
    const bet = betLog.find(b => b.id === betId);
    if (bet) {
        bet.result = result;
        saveBetLog();
        renderBetLog();
    }
}

function deleteBet(betId) {
    if (confirm('Delete this bet?')) {
        betLog = betLog.filter(b => b.id !== betId);
        saveBetLog();
        renderBetLog();
    }
}

function clearBets() {
    if (confirm('Clear all bets? This cannot be undone.')) {
        betLog = [];
        saveBetLog();
        renderBetLog();
    }
}

function exportBetsCSV() {
    if (!betLog.length) {
        alert('No bets to export');
        return;
    }
    
    // Match spreadsheet format: Date, Market, Prop #, Juice, Risk, Book, To Win
    const headers = ['Date', 'Market', 'Prop #', 'Juice', 'Risk', 'Book', 'To Win'];
    const rows = betLog.map(bet => {
        const bkd = BOOKS[bet.book] || {n: bet.book};
        return [
            bet.date,
            bet.market,
            bet.propNum || '',
            bet.juice,
            bet.risk.toFixed(2),
            bkd.n,
            bet.toWin.toFixed(2)
        ];
    });
    
    const csv = [headers, ...rows].map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(',')).join('\n');
    
    const blob = new Blob([csv], {type: 'text/csv'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `nhl-period-bets-${new Date().toISOString().split('T')[0]}.csv`;
    a.click();
    URL.revokeObjectURL(url);
}

function toggleMobile() {
    mobileMode = !mobileMode;
    document.body.classList.toggle('mobile-mode', mobileMode);
    localStorage.setItem('ppMobile', mobileMode ? '1' : '0');
}

document.addEventListener('DOMContentLoaded', () => {
    loadCfg();
    renderBookSelectors();
    loadBetLog();
    loadBookAliases();
    const k = localStorage.getItem('sgKey');
    if (k) { document.getElementById('apiKey').value = k; CFG.apiKey = k; }
    // Load mobile state
    if (localStorage.getItem('ppMobile') === '1') {
        mobileMode = true;
        document.body.classList.add('mobile-mode');
    }
});

function loadCfg() {
    const s = localStorage.getItem('cbbCfg');
    if (s) {
        Object.assign(CFG, JSON.parse(s));
        document.getElementById('minEV').value = CFG.minEV;
        document.getElementById('devigMethod').value = CFG.devigMethod || 'additive';
        document.getElementById('refreshInt').value = CFG.refresh;
        document.getElementById('alertSound').value = CFG.sound ? 'on' : 'off';
        document.getElementById('webhookEnabled').value = CFG.webhookEnabled ? 'on' : 'off';
        document.getElementById('webhookUrl').value = CFG.webhookUrl || '';
        document.getElementById('telegramEnabled').value = CFG.telegramEnabled ? 'on' : 'off';
        document.getElementById('telegramToken').value = CFG.telegramToken || '';
        document.getElementById('telegramChatId').value = CFG.telegramChatId || '';
        document.getElementById('telegramMinEV').value = CFG.telegramMinEV || 5;
        // Steam settings
        document.getElementById('steamEnabled').value = CFG.steamEnabled !== false ? 'on' : 'off';
        document.getElementById('steamSpreadMove').value = CFG.steamSpreadMove || 1.0;
        document.getElementById('steamTotalMove').value = CFG.steamTotalMove || 1.5;
        document.getElementById('steamTimeWindow').value = CFG.steamTimeWindow || 3;
        // Arb settings
        document.getElementById('arbEnabled').value = CFG.arbEnabled !== false ? 'on' : 'off';
        document.getElementById('minArb').value = CFG.minArb || 0.5;
        document.getElementById('arbTelegramEnabled').value = CFG.arbTelegramEnabled ? 'on' : 'off';
    }
}

function saveCfg() {
    CFG.apiKey = document.getElementById('apiKey').value;
    CFG.minEV = parseFloat(document.getElementById('minEV').value);
    CFG.devigMethod = document.getElementById('devigMethod').value;
    CFG.refresh = parseInt(document.getElementById('refreshInt').value);
    CFG.sound = document.getElementById('alertSound').value === 'on';
    CFG.webhookEnabled = document.getElementById('webhookEnabled').value === 'on';
    CFG.webhookUrl = document.getElementById('webhookUrl').value;
    CFG.telegramEnabled = document.getElementById('telegramEnabled').value === 'on';
    CFG.telegramToken = document.getElementById('telegramToken').value;
    CFG.telegramChatId = document.getElementById('telegramChatId').value;
    CFG.telegramMinEV = parseFloat(document.getElementById('telegramMinEV').value);
    // Steam settings
    CFG.steamEnabled = document.getElementById('steamEnabled').value === 'on';
    CFG.steamSpreadMove = parseFloat(document.getElementById('steamSpreadMove').value);
    CFG.steamTotalMove = parseFloat(document.getElementById('steamTotalMove').value);
    CFG.steamTimeWindow = parseInt(document.getElementById('steamTimeWindow').value);
    // Arb settings
    CFG.arbEnabled = document.getElementById('arbEnabled').value === 'on';
    CFG.minArb = parseFloat(document.getElementById('minArb').value);
    CFG.arbTelegramEnabled = document.getElementById('arbTelegramEnabled').value === 'on';
    localStorage.setItem('sgKey', CFG.apiKey);
    localStorage.setItem('cbbCfg', JSON.stringify(CFG));
}

function renderBookSelectors() {
    const sharpEl = document.getElementById('sharpSelector');
    const compareEl = document.getElementById('compareSelector');
    
    sharpEl.innerHTML = SHARP_LIST.map(k => 
        `<div class="book-tag ${CFG.sharpBooks.includes(k) ? 'selected sharp' : ''}" onclick="toggleSharp('${k}')">${BOOKS[k].n}</div>`
    ).join('');
    
    compareEl.innerHTML = [...SOFT_LIST, ...SHARP_LIST].map(k => 
        `<div class="book-tag ${CFG.compareBooks.includes(k) ? 'selected' : ''}" onclick="toggleCompare('${k}')">${BOOKS[k].n}</div>`
    ).join('');
}

function toggleSharp(k) {
    const i = CFG.sharpBooks.indexOf(k);
    if (i > -1) CFG.sharpBooks.splice(i, 1);
    else CFG.sharpBooks.push(k);
    renderBookSelectors();
    saveCfg();
    if (DATA.length) render();
}

function toggleCompare(k) {
    const i = CFG.compareBooks.indexOf(k);
    if (i > -1) CFG.compareBooks.splice(i, 1);
    else CFG.compareBooks.push(k);
    renderBookSelectors();
    saveCfg();
    if (DATA.length) render();
}

function toggleConfig() { document.getElementById('config').classList.toggle('show'); }
function setStatus(on, txt) { document.getElementById('dot').className = 'dot' + (on ? '' : ' off'); document.getElementById('statusTxt').textContent = txt; }

let isFirstLoad = true;

async function fetchData() {
    saveCfg();
    if (!CFG.apiKey) { alert('Enter API key in Settings'); toggleConfig(); return; }
    document.getElementById('debug').style.display = 'block';
    
    // Only show loading spinner on first load
    if (isFirstLoad) {
        document.getElementById('log').textContent = '';
        setStatus(false, 'Loading...');
        document.getElementById('games').innerHTML = '<div class="loading"><div class="spinner"></div></div>';
    } else {
        setStatus(false, 'Refreshing...');
    }
    
    try {
        // Get today's date and tomorrow for date range
        const today = new Date();
        const tomorrow = new Date(today);
        tomorrow.setDate(tomorrow.getDate() + 1);
        const formatDate = (d) => d.toISOString().split('T')[0];
        
        let allEvents = [];
        
        // Fetch all pages of NCAAB events
        let page = 1;
        let hasMore = true;
        log('Basketball leagues: NCAAB, NCAAF');
        log('Fetching NCAAB...');
        
        while (hasMore && page <= 10) { // Safety limit of 10 pages
            const url = `https://api.sportsgameodds.com/v2/events?apiKey=${CFG.apiKey}&leagueID=NCAAB&oddsAvailable=true&includeOpposingOdds=true&limit=100&page=${page}&startsAfter=${formatDate(today)}T00:00:00Z&startsBefore=${formatDate(tomorrow)}T23:59:59Z`;
            
            const res = await fetch(url);
            if (!res.ok) {
                log(`NCAAB page ${page} error: ${res.status}`);
                break;
            }
            
            const json = await res.json();
            const events = json.data || [];
            
            if (events.length === 0) {
                hasMore = false;
            } else {
                allEvents = [...allEvents, ...events];
                log(`NCAAB page ${page}: ${events.length} events (total: ${allEvents.length})`);
                page++;
                
                // Check if we got less than limit (meaning no more pages)
                if (events.length < 100) {
                    hasMore = false;
                }
            }
        }
        
        log(`Got ${allEvents.length} events`);
        
        // Dedupe by eventID
        const seen = new Set();
        let events = allEvents.filter(e => {
            if (seen.has(e.eventID)) return false;
            seen.add(e.eventID);
            return true;
        });
        
        log(`Total unique events: ${events.length}`);
        
        // Log first event's odds keys to debug
        if (events.length > 0 && events[0].odds) {
            log('Odds keys: ' + Object.keys(events[0].odds).slice(0, 5).join(', '));
        }
        
        // Debug first event
        if (events.length > 0) {
            const e = events[0];
            const st = e.status || {};
            log(`First: ${e.teams?.away?.names?.short} @ ${e.teams?.home?.names?.short}`);
            log(`Status: started=${st.started}, completed=${st.completed}, ended=${st.ended}, cancelled=${st.cancelled}`);
        }
        
        // Properly detect live games using status object
        const live = events.filter(e => {
            const st = e.status || {};
            return st.started === true && st.completed !== true && st.ended !== true && st.cancelled !== true;
        });
        log(`Live: ${live.length}`);
        
        // Show live games first, then upcoming (not started, not completed/ended/cancelled)
        const upcoming = events.filter(e => {
            const st = e.status || {};
            // Must NOT be started, completed, ended, or cancelled
            if (st.started === true) return false;
            if (st.completed === true) return false;
            if (st.ended === true) return false;
            if (st.cancelled === true) return false;
            return true;
        });
        
        // Also count completed/cancelled
        const completed = events.filter(e => {
            const st = e.status || {};
            return st.completed === true || st.ended === true || st.cancelled === true;
        });
        log(`Upcoming: ${upcoming.length}, Completed/Cancelled: ${completed.length}`);
        
        // Log first upcoming event details for debugging
        if (upcoming.length > 0) {
            const e = upcoming[0];
            log(`First upcoming: ${e.teams?.away?.names?.short || 'Away'} @ ${e.teams?.home?.names?.short || 'Home'}`);
            if (e.startTime || e.status?.startsAt) log(`Start: ${e.startTime || e.status?.startsAt}`);
        }
        
        // Show all live and upcoming games (no artificial limit)
        const toShow = [...live, ...upcoming];
        
        DATA = toShow.map(e => ({ game: e, odds: extractOdds(e.odds || {}) }));
        
        log(`Showing ${DATA.length} games (${live.length} live, ${DATA.length - live.length} upcoming)`);
        
        render(!isFirstLoad); // Pass true for refresh after first load
        updateStats();
        trackAllConsensusLines(); // Track consensus lines for steam alerts
        setStatus(true, live.length > 0 ? `${live.length} Live` : 'Connected');
        
        isFirstLoad = false;
        
        if (timer) clearInterval(timer);
        timer = setInterval(fetchData, CFG.refresh * 1000);
    } catch (err) {
        log('Error: ' + err.message);
        setStatus(false, 'Error');
        if (isFirstLoad) {
            document.getElementById('games').innerHTML = `<div class="empty"><div class="empty-icon">‚ö†Ô∏è</div><h3>Error</h3><p>${err.message}</p></div>`;
        }
    }
}

function extractOdds(odds) {
    const r = {
        'game': { spread: { books: [] }, total: { line: 0, books: [] }, ml: { books: [] } },
        '1h': { spread: { books: [] }, total: { line: 0, books: [] }, ml: { books: [] } }
    };
    
    for (const [id, o] of Object.entries(odds)) {
        // Format: {statID}-{statEntityID}-{periodID}-{betTypeID}-{sideID}
        // Examples: points-home-game-sp-home, points-all-game-ou-over, points-home-game-ml-home
        const parts = id.split('-');
        if (parts.length < 5) continue;
        
        const [statID, entityID, periodID, betTypeID, sideID] = parts;
        
        // Only process points stats
        if (statID !== 'points') continue;
        
        // Map period
        const period = (periodID === 'game' || periodID === 'game') ? 'game' : periodID;
        if (!r[period]) continue;
        
        // Spreads (sp)
        if (betTypeID === 'sp' && (sideID === 'home' || sideID === 'away')) {
            if (o.byBookmaker) {
                for (const [bk, bd] of Object.entries(o.byBookmaker)) {
                    if (!bd.available) continue;
                    let be = r[period].spread.books.find(x => x.bk === bk);
                    if (!be) { be = { bk }; r[period].spread.books.push(be); }
                    const line = parseFloat(bd.spread || bd.handicap) || 0;
                    const price = parseInt(bd.odds);
                    if (sideID === 'home') { be.homeLine = line; be.homePrice = price; }
                    if (sideID === 'away') { be.awayLine = line; be.awayPrice = price; }
                }
            }
        }
        
        // Totals (ou)
        if (betTypeID === 'ou' && (sideID === 'over' || sideID === 'under')) {
            const line = parseFloat(o.bookOverUnder || o.fairOverUnder || o.overUnder) || 0;
            if (line > 0) r[period].total.line = line;
            
            if (o.byBookmaker) {
                for (const [bk, bd] of Object.entries(o.byBookmaker)) {
                    if (!bd.available) continue;
                    let be = r[period].total.books.find(x => x.bk === bk);
                    const bookLine = parseFloat(bd.overUnder) || line;
                    if (!be) { be = { bk, line: bookLine }; r[period].total.books.push(be); }
                    if (sideID === 'over') be.overPrice = parseInt(bd.odds);
                    if (sideID === 'under') be.underPrice = parseInt(bd.odds);
                }
            }
        }
        
        // Moneyline (ml)
        if (betTypeID === 'ml' && (sideID === 'home' || sideID === 'away')) {
            if (o.byBookmaker) {
                for (const [bk, bd] of Object.entries(o.byBookmaker)) {
                    if (!bd.available) continue;
                    let be = r[period].ml.books.find(x => x.bk === bk);
                    if (!be) { be = { bk }; r[period].ml.books.push(be); }
                    const price = parseInt(bd.odds);
                    if (sideID === 'home') be.homePrice = price;
                    if (sideID === 'away') be.awayPrice = price;
                }
            }
        }
    }
    
    return r;
}

// Math
const a2d = a => a >= 100 ? (a/100)+1 : (100/Math.abs(a))+1;
const a2p = a => a >= 100 ? 100/(a+100) : Math.abs(a)/(Math.abs(a)+100);
const p2a = p => p >= 0.5 ? Math.round(-100*p/(1-p)) : Math.round(100*(1-p)/p);

// Devigging methods
function noVigAdditive(o, u) {
    // Basic/Proportional: divide each by total to normalize
    const op = a2p(o), up = a2p(u), t = op + up;
    return { o: op/t, u: up/t };
}

function noVigMultiplicative(o, u) {
    // Power method: find k where op^k + up^k = 1
    const op = a2p(o), up = a2p(u);
    // Binary search for k
    let lo = 0.5, hi = 1.5;
    for (let i = 0; i < 50; i++) {
        const mid = (lo + hi) / 2;
        const sum = Math.pow(op, mid) + Math.pow(up, mid);
        if (sum > 1) lo = mid;
        else hi = mid;
    }
    const k = (lo + hi) / 2;
    return { o: Math.pow(op, k), u: Math.pow(up, k) };
}

function noVigShin(o, u) {
    // Shin method: accounts for informed bettors
    const op = a2p(o), up = a2p(u);
    const total = op + up;
    const z = total - 1; // vig/margin
    
    // Shin formula: p_true = (sqrt(z^2 + 4(1-z)*p_implied^2) - z) / (2*(1-z))
    const shinProb = (p) => {
        if (z <= 0) return p / total;
        const discriminant = z*z + 4*(1-z)*p*p;
        return (Math.sqrt(discriminant) - z) / (2*(1-z));
    };
    
    return { o: shinProb(op), u: shinProb(up) };
}

function noVigWorstCase(o, u) {
    // Worst case: assume all vig on your side
    const op = a2p(o), up = a2p(u);
    const total = op + up;
    const vig = total - 1;
    
    // Each side gets fair value by removing full vig from itself
    return { 
        o: Math.max(0.01, Math.min(0.99, op - vig)), 
        u: Math.max(0.01, Math.min(0.99, up - vig))
    };
}

function noVig(o, u) {
    switch(CFG.devigMethod) {
        case 'multiplicative': return noVigMultiplicative(o, u);
        case 'shin': return noVigShin(o, u);
        case 'worstcase': return noVigWorstCase(o, u);
        case 'additive':
        default: return noVigAdditive(o, u);
    }
}
const calcEV = (odds, fp) => ((fp * a2d(odds)) - 1) * 100;
const fmt = o => o > 0 ? '+' + o : String(o);

// Sound alert
function beep() {
    try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = 880;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
        osc.start(ctx.currentTime);
        osc.stop(ctx.currentTime + 0.3);
    } catch(e) { console.log('Beep error:', e); }
}

// Consensus for totals (over/under)
function consensusTotal(books) {
    const sb = books.filter(b => CFG.sharpBooks.includes(b.bk?.toLowerCase()) && b.overPrice && b.underPrice);
    if (!sb.length) return null;
    let to=0, tu=0;
    sb.forEach(b => { const nv = noVig(b.overPrice, b.underPrice); to += nv.o; tu += nv.u; });
    const line = sb[0]?.line || 0;
    return { oP: to/sb.length, uP: tu/sb.length, oFair: p2a(to/sb.length), uFair: p2a(tu/sb.length), line, cnt: sb.length };
}

// Consensus for spreads (home/away)
function consensusSpread(books) {
    const sb = books.filter(b => CFG.sharpBooks.includes(b.bk?.toLowerCase()) && b.homePrice && b.awayPrice);
    if (!sb.length) return null;
    let th=0, ta=0;
    sb.forEach(b => { const nv = noVig(b.homePrice, b.awayPrice); th += nv.o; ta += nv.u; });
    const homeLine = sb[0]?.homeLine || 0;
    const awayLine = sb[0]?.awayLine || 0;
    return { hP: th/sb.length, aP: ta/sb.length, hFair: p2a(th/sb.length), aFair: p2a(ta/sb.length), homeLine, awayLine, cnt: sb.length };
}

// Consensus for moneyline (home/away)
function consensusML(books) {
    const sb = books.filter(b => CFG.sharpBooks.includes(b.bk?.toLowerCase()) && b.homePrice && b.awayPrice);
    if (!sb.length) return null;
    let th=0, ta=0;
    sb.forEach(b => { const nv = noVig(b.homePrice, b.awayPrice); th += nv.o; ta += nv.u; });
    return { hP: th/sb.length, aP: ta/sb.length, hFair: p2a(th/sb.length), aFair: p2a(ta/sb.length), cnt: sb.length };
}

// Arbitrage calculation
function calcArb(odds1, odds2) {
    // Returns arb % if positive (profit), negative if no arb
    const p1 = a2p(odds1);
    const p2 = a2p(odds2);
    const total = p1 + p2;
    if (total >= 1) return null; // No arb
    const arbPct = ((1 / total) - 1) * 100;
    return arbPct;
}

function findArbitrageOpportunities(pd, g) {
    const arbs = [];
    
    // Check spreads for arb (same line, opposite sides, different books)
    const spreadBooks = pd.spread.books.filter(b => CFG.compareBooks.includes(b.bk?.toLowerCase()) && b.homePrice && b.awayPrice);
    for (let i = 0; i < spreadBooks.length; i++) {
        for (let j = i + 1; j < spreadBooks.length; j++) {
            const b1 = spreadBooks[i], b2 = spreadBooks[j];
            // Check home@b1 vs away@b2
            if (b1.homeLine === b2.awayLine * -1 || Math.abs(b1.homeLine + b2.awayLine) < 0.01) {
                const arb = calcArb(b1.homePrice, b2.awayPrice);
                if (arb && arb >= CFG.minArb) {
                    arbs.push({ type: 'spread', side1: 'H', book1: b1.bk, odds1: b1.homePrice, line1: b1.homeLine, 
                               side2: 'A', book2: b2.bk, odds2: b2.awayPrice, line2: b2.awayLine, arb });
                }
            }
            // Check away@b1 vs home@b2
            if (b1.awayLine === b2.homeLine * -1 || Math.abs(b1.awayLine + b2.homeLine) < 0.01) {
                const arb = calcArb(b1.awayPrice, b2.homePrice);
                if (arb && arb >= CFG.minArb) {
                    arbs.push({ type: 'spread', side1: 'A', book1: b1.bk, odds1: b1.awayPrice, line1: b1.awayLine,
                               side2: 'H', book2: b2.bk, odds2: b2.homePrice, line2: b2.homeLine, arb });
                }
            }
        }
    }
    
    // Check totals for arb (same line, over vs under, different books)
    const totalBooks = pd.total.books.filter(b => CFG.compareBooks.includes(b.bk?.toLowerCase()) && b.overPrice && b.underPrice);
    for (let i = 0; i < totalBooks.length; i++) {
        for (let j = i + 1; j < totalBooks.length; j++) {
            const b1 = totalBooks[i], b2 = totalBooks[j];
            if (b1.line === b2.line) {
                // Over@b1 vs Under@b2
                const arb1 = calcArb(b1.overPrice, b2.underPrice);
                if (arb1 && arb1 >= CFG.minArb) {
                    arbs.push({ type: 'total', side1: 'O', book1: b1.bk, odds1: b1.overPrice, line1: b1.line,
                               side2: 'U', book2: b2.bk, odds2: b2.underPrice, line2: b2.line, arb: arb1 });
                }
                // Under@b1 vs Over@b2
                const arb2 = calcArb(b1.underPrice, b2.overPrice);
                if (arb2 && arb2 >= CFG.minArb) {
                    arbs.push({ type: 'total', side1: 'U', book1: b1.bk, odds1: b1.underPrice, line1: b1.line,
                               side2: 'O', book2: b2.bk, odds2: b2.overPrice, line2: b2.line, arb: arb2 });
                }
            }
        }
    }
    
    // Check moneyline for arb
    const mlBooks = pd.ml.books.filter(b => CFG.compareBooks.includes(b.bk?.toLowerCase()) && b.homePrice && b.awayPrice);
    for (let i = 0; i < mlBooks.length; i++) {
        for (let j = i + 1; j < mlBooks.length; j++) {
            const b1 = mlBooks[i], b2 = mlBooks[j];
            // Home@b1 vs Away@b2
            const arb1 = calcArb(b1.homePrice, b2.awayPrice);
            if (arb1 && arb1 >= CFG.minArb) {
                arbs.push({ type: 'ml', side1: 'H', book1: b1.bk, odds1: b1.homePrice, line1: null,
                           side2: 'A', book2: b2.bk, odds2: b2.awayPrice, line2: null, arb: arb1 });
            }
            // Away@b1 vs Home@b2
            const arb2 = calcArb(b1.awayPrice, b2.homePrice);
            if (arb2 && arb2 >= CFG.minArb) {
                arbs.push({ type: 'ml', side1: 'A', book1: b1.bk, odds1: b1.awayPrice, line1: null,
                           side2: 'H', book2: b2.bk, odds2: b2.homePrice, line2: null, arb: arb2 });
            }
        }
    }
    
    return arbs;
}

// Steam move detection
function trackConsensusLine(eventId, period, type, line, game) {
    if (line === null || line === undefined || isNaN(line)) return;
    
    const key = `${eventId}-${period}-${type}`;
    const now = Date.now();
    
    if (!consensusHistory[key]) {
        consensusHistory[key] = [];
    }
    
    const history = consensusHistory[key];
    const lastEntry = history[history.length - 1];
    
    // Only add if line changed
    if (!lastEntry || lastEntry.line !== line) {
        history.push({ line, timestamp: now, game });
        
        // Clean up old entries (keep last 10 minutes worth)
        const cutoff = now - (10 * 60 * 1000);
        consensusHistory[key] = history.filter(h => h.timestamp > cutoff);
        
        // Check for steam move
        checkSteamMove(eventId, period, type, game);
    }
}

function checkSteamMove(eventId, period, type, game) {
    if (!CFG.steamEnabled) return;
    
    const key = `${eventId}-${period}-${type}`;
    const history = consensusHistory[key];
    if (!history || history.length < 2) return;
    
    const now = Date.now();
    const timeWindow = CFG.steamTimeWindow * 60 * 1000; // Convert minutes to ms
    const threshold = type === 'spread' ? CFG.steamSpreadMove : CFG.steamTotalMove;
    
    // Get entries within time window
    const recentEntries = history.filter(h => (now - h.timestamp) <= timeWindow);
    if (recentEntries.length < 2) return;
    
    const oldestInWindow = recentEntries[0];
    const newest = recentEntries[recentEntries.length - 1];
    
    const movement = Math.abs(newest.line - oldestInWindow.line);
    
    if (movement >= threshold) {
        const direction = newest.line > oldestInWindow.line ? 'üìà' : 'üìâ';
        const alertKey = `${key}-${oldestInWindow.line}-${newest.line}`;
        
        // Avoid duplicate alerts
        if (steamAlerted.has(alertKey)) return;
        steamAlerted.add(alertKey);
        
        // Clear old alerts after 5 minutes
        setTimeout(() => steamAlerted.delete(alertKey), 5 * 60 * 1000);
        
        showSteamAlert(game, period, type, oldestInWindow.line, newest.line, movement, direction);
    }
}

function showSteamAlert(game, period, type, oldLine, newLine, movement, direction) {
    const t = game.teams || {};
    const away = t.away?.names?.short || t.away?.names?.abbr || 'Away';
    const home = t.home?.names?.short || t.home?.names?.abbr || 'Home';
    const periodLabel = period === 'game' ? 'FG' : '1H';
    const typeLabel = type === 'spread' ? 'Spread' : 'Total';
    
    const formatLine = (line, type) => {
        if (type === 'spread') {
            return line > 0 ? `+${line}` : line;
        }
        return line;
    };
    
    // Play sound
    if (CFG.sound) {
        try {
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.connect(gain);
            gain.connect(ctx.destination);
            osc.frequency.value = 880; // Higher pitch for steam
            osc.type = 'sine';
            gain.gain.setValueAtTime(0.3, ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
            osc.start(ctx.currentTime);
            osc.stop(ctx.currentTime + 0.3);
        } catch(e) {}
    }
    
    // Send to Telegram
    sendSteamTelegram(away, home, periodLabel, typeLabel, oldLine, newLine, movement, type);
    
    const c = document.getElementById('alerts');
    const id = 'steam' + Date.now();
    c.insertAdjacentHTML('afterbegin', `<div class="alert steam-alert" id="${id}" onclick="dismissAlert('${id}')">
        <div class="alert-header">
            <span class="alert-title">${direction} STEAM MOVE</span>
            <span class="alert-time">${new Date().toLocaleTimeString([], {hour:'numeric', minute:'2-digit'})}</span>
        </div>
        <div class="alert-body">
            <strong>${away} @ ${home}</strong> ${periodLabel} ${typeLabel}<br>
            ${formatLine(oldLine, type)} ‚Üí ${formatLine(newLine, type)} <span class="steam-move">(${movement.toFixed(1)} pts in ${CFG.steamTimeWindow}min)</span>
        </div>
    </div>`);
    
    // Auto-dismiss after 2 minutes
    setTimeout(() => dismissAlert(id), 120000);
    
    log(`üö® STEAM: ${away}@${home} ${periodLabel} ${typeLabel} moved ${movement.toFixed(1)} pts`);
}

async function sendSteamTelegram(away, home, periodLabel, typeLabel, oldLine, newLine, movement, type) {
    if (!CFG.telegramEnabled || !CFG.telegramToken || !CFG.telegramChatId) return;
    
    const formatLine = (line) => {
        if (type === 'spread') {
            return line > 0 ? `+${line}` : line;
        }
        return line;
    };
    
    const direction = newLine > oldLine ? 'üìà' : 'üìâ';
    
    const message = `${direction} *STEAM MOVE* üö®

*${away} @ ${home}*
üìä ${periodLabel} ${typeLabel}
${formatLine(oldLine)} ‚Üí ${formatLine(newLine)}
‚ö° *${movement.toFixed(1)} pts in ${CFG.steamTimeWindow}min*`;

    try {
        await fetch(`https://api.telegram.org/bot${CFG.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: CFG.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        console.log('Steam Telegram sent:', `${away}@${home} ${periodLabel} ${typeLabel}`);
    } catch(err) {
        console.error('Steam Telegram error:', err);
    }
}

function trackAllConsensusLines() {
    DATA.forEach(({game, odds}) => {
        ['game', '1h'].forEach(period => {
            const pd = odds[period];
            if (!pd) return;
            
            // Track spread consensus
            const spreadCons = consensusSpread(pd.spread.books);
            if (spreadCons && spreadCons.homeLine !== undefined) {
                trackConsensusLine(game.eventID, period, 'spread', spreadCons.homeLine, game);
            }
            
            // Track total consensus
            const totalCons = consensusTotal(pd.total.books);
            if (totalCons && totalCons.line) {
                trackConsensusLine(game.eventID, period, 'total', totalCons.line, game);
            }
        });
    });
}

function render(isRefresh = false) {
    const c = document.getElementById('games');
    if (!DATA.length) { c.innerHTML = '<div class="empty"><div class="empty-icon">üèÄ</div><h3>No Games</h3><p>Click Demo to preview</p></div>'; return; }
    
    const scrollY = window.scrollY;
    const activeTabs = {};
    const seenGames = new Set();
    document.querySelectorAll('.game').forEach(g => {
        const id = g.id.replace('g-', '');
        const activeTab = g.querySelector('.period-tab.active');
        if (activeTab) activeTabs[id] = activeTab.dataset.p;
        if (g.classList.contains('seen')) seenGames.add(id);
    });
    
    // Sort data: pinned games first, then by start time
    const sortedData = [...DATA].sort((a, b) => {
        const aPinned = pinnedGames.has(a.game.eventID);
        const bPinned = pinnedGames.has(b.game.eventID);
        if (aPinned && !bPinned) return -1;
        if (!aPinned && bPinned) return 1;
        return 0;
    });
    
    if (isRefresh && c.children.length > 0) {
        sortedData.forEach(({game: g, odds}) => {
            const existingGame = document.getElementById('g-' + g.eventID);
            const savedPeriod = activeTabs[g.eventID] || 'game';
            const edge = hasEdge(odds, g);
            const wasSeen = seenGames.has(g.eventID);
            const isPinned = pinnedGames.has(g.eventID);
            const isCollapsed = collapsedGames.has(g.eventID);
            
            if (existingGame) {
                existingGame.innerHTML = `${gameHeader(g, odds)}${periodTabs(g, odds, savedPeriod)}${oddsSection(g, odds, savedPeriod)}${collapsedSummary(g, odds)}`;
                existingGame.className = `game${edge ? ' has-edge' : ''}${wasSeen ? ' seen' : ''}${isPinned ? ' pinned' : ''}${isCollapsed ? ' collapsed' : ''}`;
            } else {
                const newGame = document.createElement('div');
                newGame.className = `game${edge ? ' has-edge' : ''}${isPinned ? ' pinned' : ''}${isCollapsed ? ' collapsed' : ''}`;
                newGame.id = 'g-' + g.eventID;
                newGame.onclick = (e) => { if (!e.target.closest('button')) markSeen(g.eventID); };
                newGame.innerHTML = `${gameHeader(g, odds)}${periodTabs(g, odds, savedPeriod)}${oddsSection(g, odds, savedPeriod)}${collapsedSummary(g, odds)}`;
                c.appendChild(newGame);
            }
        });
        
        const currentIds = new Set(DATA.map(d => 'g-' + d.game.eventID));
        Array.from(c.children).forEach(child => { if (!currentIds.has(child.id)) child.remove(); });
        
        // Re-order DOM to match sorted order
        sortedData.forEach(({game: g}) => {
            const el = document.getElementById('g-' + g.eventID);
            if (el) c.appendChild(el);
        });
    } else {
        c.innerHTML = sortedData.map(({game: g, odds}) => {
            const edge = hasEdge(odds, g);
            const savedPeriod = activeTabs[g.eventID] || 'game';
            const wasSeen = seenGames.has(g.eventID);
            const isPinned = pinnedGames.has(g.eventID);
            const isCollapsed = collapsedGames.has(g.eventID);
            return `<div class="game${edge ? ' has-edge' : ''}${wasSeen ? ' seen' : ''}${isPinned ? ' pinned' : ''}${isCollapsed ? ' collapsed' : ''}" id="g-${g.eventID}" onclick="if(!event.target.closest('button'))markSeen('${g.eventID}')">${gameHeader(g, odds)}${periodTabs(g, odds, savedPeriod)}${oddsSection(g, odds, savedPeriod)}${collapsedSummary(g, odds)}</div>`;
        }).join('');
    }
    
    requestAnimationFrame(() => { window.scrollTo(0, scrollY); });
}

function markSeen(eventId) {
    const game = document.getElementById('g-' + eventId);
    if (game) game.classList.add('seen');
}

function gameHeader(g, odds) {
    const t = g.teams || {};
    const aw = t.away || {}, hm = t.home || {};
    
    // Handle various name formats - ensure we always get a string
    const getAbbr = (team) => {
        if (!team || !team.names) {
            if (team?.teamID) return String(team.teamID).split('_')[0].substring(0, 4).toUpperCase();
            return 'TBD';
        }
        const names = team.names;
        if (typeof names === 'string') return names.substring(0, 4).toUpperCase();
        if (names.abbr) return String(names.abbr);
        if (names.short) return String(names.short).substring(0, 4).toUpperCase();
        if (team.teamID) return String(team.teamID).split('_')[0].substring(0, 4).toUpperCase();
        return 'TBD';
    };
    
    const getName = (team) => {
        if (!team || !team.names) {
            if (team?.teamID) return String(team.teamID).replace(/_/g, ' ');
            return 'TBD';
        }
        const names = team.names;
        if (typeof names === 'string') return names;
        // Prefer longer names: medium > long > short > abbr
        if (names.medium) return String(names.medium);
        if (names.long) return String(names.long);
        if (names.short) return String(names.short);
        if (names.abbr) return String(names.abbr);
        if (team.teamID) return String(team.teamID).replace(/_/g, ' ');
        return 'TBD';
    };
    
    const awA = getAbbr(aw);
    const hmA = getAbbr(hm);
    const awN = getName(aw);
    const hmN = getName(hm);
    
    let awS = 0, hmS = 0;
    if (g.results) {
        const pts = Object.values(g.results).find(r => r.away !== undefined && r.home !== undefined);
        if (pts) { awS = pts.away || 0; hmS = pts.home || 0; }
    }
    if (g.score) {
        awS = g.score.away?.total ?? g.score.away ?? awS;
        hmS = g.score.home?.total ?? g.score.home ?? hmS;
    }
    
    const st = g.status || {};
    const isLive = st.started && !st.completed;
    const startTime = g.startTime || st.startsAt;
    const timeStr = startTime ? new Date(startTime).toLocaleTimeString([], {hour:'numeric', minute:'2-digit'}) : '--';
    
    // Get timezone abbreviation
    const tzAbbr = new Date().toLocaleTimeString('en-US', {timeZoneName: 'short'}).split(' ').pop();
    
    // Get game clock/period info for live games
    let clockDisplay = '';
    if (isLive) {
        const period = st.period || st.quarter || st.half;
        const clock = st.clock || st.gameClock || st.displayClock || st.displayShort;
        if (clock) {
            clockDisplay = clock;
        } else if (period) {
            clockDisplay = `${period}${period === 1 ? 'st' : period === 2 ? 'nd' : period === 3 ? 'rd' : 'th'}`;
        }
        // Check for timeout/halftime status (if API provides it)
        if (st.inTimeout || st.timeout) {
            clockDisplay += ' ‚è∏Ô∏è TO';
        } else if (st.halftime || st.isHalftime) {
            clockDisplay = 'HALF';
        }
    }
    
    let gameInfoContent = '';
    if (isLive) {
        gameInfoContent = `
            <div class="game-status live"><span class="live-dot"></span>LIVE</div>
            ${clockDisplay ? `<div class="game-clock">${clockDisplay}</div>` : ''}`;
    } else if (st.completed || st.ended) {
        gameInfoContent = `<span class="game-status final">Final</span>`;
    } else {
        gameInfoContent = `
            <span class="game-status upcoming">Upcoming</span>
            <span class="game-time">${timeStr}<span class="game-time-tz">${tzAbbr}</span></span>`;
    }
    
    const isPinned = pinnedGames.has(g.eventID);
    const isCollapsed = collapsedGames.has(g.eventID);
    
    return `<div class="game-header">
        <div class="teams">
            <div class="team">
                <span class="team-abbr">${awA}</span>
                <span class="team-name">${awN}</span>
            </div>
            ${isLive || st.completed || st.ended ? `<span class="score">${awS}</span>` : ''}
            <span class="at">@</span>
            <div class="team">
                <span class="team-abbr">${hmA}</span>
                <span class="team-name">${hmN}</span>
            </div>
            ${isLive || st.completed || st.ended ? `<span class="score">${hmS}</span>` : ''}
        </div>
        <div class="game-right">
            <div class="game-info">
                ${gameInfoContent}
            </div>
            <div class="game-controls">
                <button class="pin-btn" onclick="event.stopPropagation(); togglePin('${g.eventID}')" title="${isPinned ? 'Unpin' : 'Pin to top'}">${isPinned ? 'üìå' : 'üìç'}</button>
                <button class="expand-btn" onclick="event.stopPropagation(); toggleGameCollapse('${g.eventID}')" title="${isCollapsed ? 'Expand' : 'Collapse'}">‚ñº</button>
            </div>
        </div>
    </div>`;
}

function periodTabs(g, odds, activePeriod) {
    const periods = [
        { id: 'game', label: 'Game' },
        { id: '1h', label: '1st Half' }
    ];
    
    return `<div class="period-tabs">
        ${periods.map(p => `<button class="period-tab${activePeriod === p.id ? ' active' : ''}" data-p="${p.id}" onclick="event.stopPropagation(); switchPeriod('${g.eventID}', '${p.id}')">${p.label}</button>`).join('')}
    </div>`;
}

let viewingPeriod = 'game';
let allCollapsed = false;
const pinnedGames = new Set();
const collapsedGames = new Set();

function switchPeriod(eventId, period) {
    const game = document.getElementById('g-' + eventId);
    if (!game) return;
    viewingPeriod = period;
    game.querySelectorAll('.period-tab').forEach(t => t.classList.toggle('active', t.dataset.p === period));
    const data = DATA.find(d => d.game.eventID === eventId);
    if (data) {
        const section = game.querySelector('.odds-section');
        if (section) section.outerHTML = oddsSection(data.game, data.odds, period);
    }
}

function collapsedSummary(g, odds) {
    const st = g.status || {};
    const isLive = st.started && !st.completed;
    const startTime = g.startTime || st.startsAt;
    const timeStr = startTime ? new Date(startTime).toLocaleTimeString([], {hour:'numeric', minute:'2-digit'}) : '--';
    
    // Get scores
    let awS = 0, hmS = 0;
    if (g.results) {
        const pts = Object.values(g.results).find(r => r.away !== undefined && r.home !== undefined);
        if (pts) { awS = pts.away || 0; hmS = pts.home || 0; }
    }
    if (g.score) {
        awS = g.score.away?.total ?? g.score.away ?? awS;
        hmS = g.score.home?.total ?? g.score.home ?? hmS;
    }
    
    // Get fair value and best lines
    const pd = odds['game'] || { spread: { books: [] }, total: { line: 0, books: [] }, ml: { books: [] } };
    const spreadCons = consensusSpread(pd.spread.books);
    const totalCons = consensusTotal(pd.total.books);
    const mlCons = consensusML(pd.ml?.books || []);
    
    // Find best lines for each side
    const bestLines = findBestLines(pd, spreadCons, totalCons, mlCons, isLive);
    
    return `<div class="collapsed-summary">
        ${isLive ? `<div class="cs-item"><span class="cs-value blue">${awS}-${hmS}</span></div>` : 
                   `<div class="cs-item"><span class="cs-value">${timeStr}</span></div>`}
        ${(spreadCons || totalCons) ? `<div class="cs-fv-stack">
            ${spreadCons ? `<div class="cs-fv-item"><span class="cs-label">FV</span><span class="cs-value purple">${spreadCons.homeLine > 0 ? '+' : ''}${spreadCons.homeLine}</span></div>` : ''}
            ${totalCons ? `<div class="cs-fv-item"><span class="cs-value purple">${totalCons.line}</span></div>` : ''}
        </div>` : ''}
        ${(bestLines.homeSpread || bestLines.awaySpread) ? `<div class="cs-best-stack">
            ${bestLines.homeSpread ? `<div class="cs-best-line"><span class="cs-side">H</span><div class="book-logo" style="background:${bestLines.homeSpread.color}">${bestLines.homeSpread.book}</div><span class="cs-odds">${bestLines.homeSpread.line > 0 ? '+' : ''}${bestLines.homeSpread.line} ${fmt(bestLines.homeSpread.price)}</span></div>` : ''}
            ${bestLines.awaySpread ? `<div class="cs-best-line"><span class="cs-side">A</span><div class="book-logo" style="background:${bestLines.awaySpread.color}">${bestLines.awaySpread.book}</div><span class="cs-odds">${bestLines.awaySpread.line > 0 ? '+' : ''}${bestLines.awaySpread.line} ${fmt(bestLines.awaySpread.price)}</span></div>` : ''}
        </div>` : ''}
        ${(bestLines.homeML || bestLines.awayML) ? `<div class="cs-best-stack">
            ${bestLines.homeML ? `<div class="cs-best-line"><span class="cs-side">H</span><div class="book-logo" style="background:${bestLines.homeML.color}">${bestLines.homeML.book}</div><span class="cs-odds">ML ${fmt(bestLines.homeML.price)}</span></div>` : ''}
            ${bestLines.awayML ? `<div class="cs-best-line"><span class="cs-side">A</span><div class="book-logo" style="background:${bestLines.awayML.color}">${bestLines.awayML.book}</div><span class="cs-odds">ML ${fmt(bestLines.awayML.price)}</span></div>` : ''}
        </div>` : ''}
        ${(bestLines.over || bestLines.under) ? `<div class="cs-best-stack">
            ${bestLines.over ? `<div class="cs-best-line"><span class="cs-side">O</span><div class="book-logo" style="background:${bestLines.over.color}">${bestLines.over.book}</div><span class="cs-odds">${bestLines.over.line} ${fmt(bestLines.over.price)}</span></div>` : ''}
            ${bestLines.under ? `<div class="cs-best-line"><span class="cs-side">U</span><div class="book-logo" style="background:${bestLines.under.color}">${bestLines.under.book}</div><span class="cs-odds">${bestLines.under.line} ${fmt(bestLines.under.price)}</span></div>` : ''}
        </div>` : ''}
    </div>`;
}

function findBestLines(pd, spreadCons, totalCons, mlCons, isLive) {
    const result = { awaySpread: null, homeSpread: null, over: null, under: null, homeML: null, awayML: null };
    
    // Find best away spread (highest price)
    let bestAwayPrice = -Infinity;
    pd.spread.books.forEach(b => {
        if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
        if (b.awayPrice && b.awayPrice > bestAwayPrice) {
            bestAwayPrice = b.awayPrice;
            const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
            result.awaySpread = { book: bkd.a, line: b.awayLine, price: b.awayPrice, color: bkd.c };
        }
    });
    
    // Find best home spread (highest price)
    let bestHomePrice = -Infinity;
    pd.spread.books.forEach(b => {
        if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
        if (b.homePrice && b.homePrice > bestHomePrice) {
            bestHomePrice = b.homePrice;
            const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
            result.homeSpread = { book: bkd.a, line: b.homeLine, price: b.homePrice, color: bkd.c };
        }
    });
    
    // Find best over (highest price)
    let bestOverPrice = -Infinity;
    pd.total.books.forEach(b => {
        if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
        if (b.overPrice && b.overPrice > bestOverPrice) {
            bestOverPrice = b.overPrice;
            const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
            result.over = { book: bkd.a, line: b.line, price: b.overPrice, color: bkd.c };
        }
    });
    
    // Find best under (highest price)
    let bestUnderPrice = -Infinity;
    pd.total.books.forEach(b => {
        if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
        if (b.underPrice && b.underPrice > bestUnderPrice) {
            bestUnderPrice = b.underPrice;
            const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
            result.under = { book: bkd.a, line: b.line, price: b.underPrice, color: bkd.c };
        }
    });
    
    // Find best home ML (highest price)
    if (pd.ml && pd.ml.books) {
        let bestHomeMLPrice = -Infinity;
        pd.ml.books.forEach(b => {
            if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
            if (b.homePrice && b.homePrice > bestHomeMLPrice) {
                bestHomeMLPrice = b.homePrice;
                const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
                result.homeML = { book: bkd.a, price: b.homePrice, color: bkd.c };
            }
        });
        
        // Find best away ML (highest price)
        let bestAwayMLPrice = -Infinity;
        pd.ml.books.forEach(b => {
            if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
            if (b.awayPrice && b.awayPrice > bestAwayMLPrice) {
                bestAwayMLPrice = b.awayPrice;
                const bkd = BOOKS[b.bk?.toLowerCase()] || {a: (b.bk || '').substring(0,3).toUpperCase(), c: '#666'};
                result.awayML = { book: bkd.a, price: b.awayPrice, color: bkd.c };
            }
        });
    }
    
    return result;
}

function togglePin(eventId) {
    if (pinnedGames.has(eventId)) {
        pinnedGames.delete(eventId);
    } else {
        pinnedGames.add(eventId);
    }
    render(true);
}

function toggleGameCollapse(eventId) {
    const game = document.getElementById('g-' + eventId);
    if (!game) return;
    
    if (collapsedGames.has(eventId)) {
        collapsedGames.delete(eventId);
        game.classList.remove('collapsed');
    } else {
        collapsedGames.add(eventId);
        game.classList.add('collapsed');
    }
}

function toggleCollapseAll() {
    allCollapsed = !allCollapsed;
    const btn = document.getElementById('collapseAllBtn');
    
    if (allCollapsed) {
        DATA.forEach(d => collapsedGames.add(d.game.eventID));
        document.querySelectorAll('.game').forEach(g => g.classList.add('collapsed'));
        btn.textContent = '‚ñ∂ Expand';
    } else {
        collapsedGames.clear();
        document.querySelectorAll('.game').forEach(g => g.classList.remove('collapsed'));
        btn.textContent = '‚ñº Collapse';
    }
}

function oddsSection(g, odds, period) {
    const pd = odds[period] || { spread: { books: [] }, total: { line: 0, books: [] }, ml: { books: [] } };
    const spreadCons = consensusSpread(pd.spread.books);
    const totalCons = consensusTotal(pd.total.books);
    const mlCons = consensusML(pd.ml.books);
    
    const st = g.status || {};
    const isLive = st.started && !st.completed;
    
    // For CBB: Only calc EV for full game pregame, or 1H pregame
    const canCalcEV = !isLive;
    
    // Generate best lines bar for expanded view
    const bestLines = findBestLines(pd, spreadCons, totalCons, mlCons, isLive);
    const bestLinesHtml = getBestLinesBar(bestLines);
    
    // Find arbitrage opportunities
    const arbs = CFG.arbEnabled ? findArbitrageOpportunities(pd, g) : [];
    const arbsHtml = arbs.length > 0 ? getArbsBar(arbs, g) : '';
    
    return `<div class="odds-section">
        ${arbsHtml}
        ${bestLinesHtml}
        <div class="market-section">
            <div class="market-header">üìä Spread</div>
            ${spreadTable(pd.spread, spreadCons, g, period, canCalcEV)}
        </div>
        <div class="market-section">
            <div class="market-header">üéØ Total</div>
            ${totalTable(pd.total, totalCons, g, period, canCalcEV)}
        </div>
        <div class="market-section">
            <div class="market-header">üíµ Moneyline</div>
            ${mlTable(pd.ml, mlCons, g, period, canCalcEV)}
        </div>
    </div>`;
}

function getArbsBar(arbs, g) {
    if (!arbs.length) return '';
    
    return `<div class="arb-bar">
        <span class="arb-label">üí∞ ARB</span>
        ${arbs.slice(0, 3).map(a => {
            const bk1 = BOOKS[a.book1?.toLowerCase()] || {a: a.book1?.substring(0,3).toUpperCase(), c: '#666'};
            const bk2 = BOOKS[a.book2?.toLowerCase()] || {a: a.book2?.substring(0,3).toUpperCase(), c: '#666'};
            const lineStr = a.line1 !== null ? (a.line1 > 0 ? '+' + a.line1 : a.line1) : '';
            return `<span class="arb-chip">
                <span class="arb-type">${a.type.toUpperCase()}</span>
                <div class="book-logo" style="background:${bk1.c}">${bk1.a}</div>${a.side1}${lineStr} ${fmt(a.odds1)}
                <span class="arb-vs">vs</span>
                <div class="book-logo" style="background:${bk2.c}">${bk2.a}</div>${a.side2} ${fmt(a.odds2)}
                <span class="arb-pct">+${a.arb.toFixed(2)}%</span>
            </span>`;
        }).join('')}
    </div>`;
}

function getBestLinesBar(bestLines) {
    const hasSpread = bestLines.homeSpread || bestLines.awaySpread;
    const hasTotal = bestLines.over || bestLines.under;
    const hasML = bestLines.homeML || bestLines.awayML;
    
    if (!hasSpread && !hasTotal && !hasML) return '';
    
    let spreadStack = '';
    if (hasSpread) {
        spreadStack = `<div class="best-bets-stack">
            ${bestLines.homeSpread ? `<span class="best-bet-chip"><span class="bet-label">H</span><div class="book-logo" style="background:${bestLines.homeSpread.color}">${bestLines.homeSpread.book}</div><span class="bet-odds">${bestLines.homeSpread.line > 0 ? '+' : ''}${bestLines.homeSpread.line} ${fmt(bestLines.homeSpread.price)}</span></span>` : ''}
            ${bestLines.awaySpread ? `<span class="best-bet-chip"><span class="bet-label">A</span><div class="book-logo" style="background:${bestLines.awaySpread.color}">${bestLines.awaySpread.book}</div><span class="bet-odds">${bestLines.awaySpread.line > 0 ? '+' : ''}${bestLines.awaySpread.line} ${fmt(bestLines.awaySpread.price)}</span></span>` : ''}
        </div>`;
    }
    
    let totalStack = '';
    if (hasTotal) {
        totalStack = `<div class="best-bets-stack">
            ${bestLines.over ? `<span class="best-bet-chip"><span class="bet-label">O</span><div class="book-logo" style="background:${bestLines.over.color}">${bestLines.over.book}</div><span class="bet-odds">${bestLines.over.line} ${fmt(bestLines.over.price)}</span></span>` : ''}
            ${bestLines.under ? `<span class="best-bet-chip"><span class="bet-label">U</span><div class="book-logo" style="background:${bestLines.under.color}">${bestLines.under.book}</div><span class="bet-odds">${bestLines.under.line} ${fmt(bestLines.under.price)}</span></span>` : ''}
        </div>`;
    }
    
    let mlStack = '';
    if (hasML) {
        mlStack = `<div class="best-bets-stack">
            ${bestLines.homeML ? `<span class="best-bet-chip"><span class="bet-label">H</span><div class="book-logo" style="background:${bestLines.homeML.color}">${bestLines.homeML.book}</div><span class="bet-odds">ML ${fmt(bestLines.homeML.price)}</span></span>` : ''}
            ${bestLines.awayML ? `<span class="best-bet-chip"><span class="bet-label">A</span><div class="book-logo" style="background:${bestLines.awayML.color}">${bestLines.awayML.book}</div><span class="bet-odds">ML ${fmt(bestLines.awayML.price)}</span></span>` : ''}
        </div>`;
    }
    
    return `<div class="best-bets-bar">
        <span class="best-bets-label">üî• Best</span>
        ${spreadStack}
        ${mlStack}
        ${totalStack}
    </div>`;
}

function spreadTable(data, cons, g, period, canCalcEV) {
    if (!data.books.length) return '<div class="empty" style="padding:12px;font-size:12px">No spread odds</div>';
    
    const show = [...new Set([...CFG.compareBooks])];
    const filtered = data.books.filter(b => show.includes(b.bk?.toLowerCase()));
    if (!filtered.length) return '<div class="empty" style="padding:12px;font-size:12px">No odds from selected books</div>';
    
    let bestHome = -Infinity, bestAway = -Infinity;
    filtered.forEach(b => {
        if (b.homePrice) bestHome = Math.max(bestHome, b.homePrice);
        if (b.awayPrice) bestAway = Math.max(bestAway, b.awayPrice);
    });
    
    return `<table class="odds-table">
        <thead><tr><th>Book</th><th>Away</th><th>Home</th><th>A EV</th><th>H EV</th></tr></thead>
        <tbody>
            ${cons ? `<tr class="consensus-row">
                <td><span class="consensus-label">‚ö° Sharp (${cons.cnt})</span></td>
                <td>${cons.awayLine > 0 ? '+' : ''}${cons.awayLine} ${fmt(cons.aFair)}</td>
                <td>${cons.homeLine > 0 ? '+' : ''}${cons.homeLine} ${fmt(cons.hFair)}</td>
                <td>--</td><td>--</td>
            </tr>` : ''}
            ${filtered.map(b => spreadRow(b, cons, bestAway, bestHome, g, period, canCalcEV)).join('')}
        </tbody>
    </table>`;
}

function spreadRow(b, cons, bestAway, bestHome, g, period, canCalcEV) {
    const bk = (b.bk || '').toLowerCase();
    const bkd = BOOKS[bk] || {n: b.bk, a: bk.substring(0,3).toUpperCase(), c: '#666'};
    
    let aEV = null, hEV = null;
    if (cons && canCalcEV) {
        if (b.awayPrice) aEV = calcEV(b.awayPrice, cons.aP);
        if (b.homePrice) hEV = calcEV(b.homePrice, cons.hP);
    }
    
    const aE = aEV && aEV >= CFG.minEV;
    const hE = hEV && hEV >= CFG.minEV;
    
    if (aE || hE) {
        const k = `${g.eventID}-${bk}-spread-${b.awayLine}-${b.awayPrice}-${b.homePrice}`;
        if (!alerted.has(k)) { 
            alerted.add(k);
            if (aE) {
                triggerAlertCBB(g, bkd, 'spread', 'away', b.awayLine, b.awayPrice, aEV);
                if (aEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'spread', 'away', b.awayLine, b.awayPrice, aEV);
            }
            if (hE) {
                triggerAlertCBB(g, bkd, 'spread', 'home', b.homeLine, b.homePrice, hEV);
                if (hEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'spread', 'home', b.homeLine, b.homePrice, hEV);
            }
        }
    }
    
    const aClass = b.awayPrice === bestAway ? 'best' : '';
    const hClass = b.homePrice === bestHome ? 'best' : '';
    
    const aClick = b.awayPrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','away spread',${b.awayLine},${b.awayPrice},${aEV !== null ? aEV : 'null'}); event.stopPropagation();"` : '';
    const hClick = b.homePrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','home spread',${b.homeLine},${b.homePrice},${hEV !== null ? hEV : 'null'}); event.stopPropagation();"` : '';
    
    return `<tr>
        <td><div class="book-cell"><div class="book-logo" style="background:${bkd.c};color:#fff">${bkd.a}</div><span class="book-name">${bkd.n}</span></div></td>
        <td class="odds-cell">${b.awayPrice ? `<span class="odds-value clickable ${aClass}" ${aClick}>${b.awayLine > 0 ? '+' : ''}${b.awayLine} ${fmt(b.awayPrice)}</span>` : '--'}</td>
        <td class="odds-cell">${b.homePrice ? `<span class="odds-value clickable ${hClass}" ${hClick}>${b.homeLine > 0 ? '+' : ''}${b.homeLine} ${fmt(b.homePrice)}</span>` : '--'}</td>
        <td class="ev-cell">${aEV !== null ? `<span class="ev-value${aEV >= CFG.minEV ? ' positive' : ' negative'}">${aEV > 0 ? '+' : ''}${aEV.toFixed(1)}%</span>` : '--'}</td>
        <td class="ev-cell">${hEV !== null ? `<span class="ev-value${hEV >= CFG.minEV ? ' positive' : ' negative'}">${hEV > 0 ? '+' : ''}${hEV.toFixed(1)}%</span>` : '--'}</td>
    </tr>`;
}

function totalTable(data, cons, g, period, canCalcEV) {
    if (!data.books.length) return '<div class="empty" style="padding:12px;font-size:12px">No total odds</div>';
    
    const show = [...new Set([...CFG.compareBooks])];
    const filtered = data.books.filter(b => show.includes(b.bk?.toLowerCase()));
    if (!filtered.length) return '<div class="empty" style="padding:12px;font-size:12px">No odds from selected books</div>';
    
    let bestOver = -Infinity, bestUnder = -Infinity;
    filtered.forEach(b => {
        if (b.overPrice) bestOver = Math.max(bestOver, b.overPrice);
        if (b.underPrice) bestUnder = Math.max(bestUnder, b.underPrice);
    });
    
    return `<table class="odds-table">
        <thead><tr><th>Book</th><th>Line</th><th>Over</th><th>Under</th><th>O EV</th><th>U EV</th></tr></thead>
        <tbody>
            ${cons ? `<tr class="consensus-row">
                <td><span class="consensus-label">‚ö° Sharp (${cons.cnt})</span></td>
                <td>${cons.line}</td>
                <td>${fmt(cons.oFair)}</td>
                <td>${fmt(cons.uFair)}</td>
                <td>--</td><td>--</td>
            </tr>` : ''}
            ${filtered.map(b => totalRow(b, cons, bestOver, bestUnder, g, period, canCalcEV)).join('')}
        </tbody>
    </table>`;
}

function totalRow(b, cons, bestOver, bestUnder, g, period, canCalcEV) {
    const bk = (b.bk || '').toLowerCase();
    const bkd = BOOKS[bk] || {n: b.bk, a: bk.substring(0,3).toUpperCase(), c: '#666'};
    
    let oEV = null, uEV = null;
    if (cons && canCalcEV) {
        if (b.overPrice) oEV = calcEV(b.overPrice, cons.oP);
        if (b.underPrice) uEV = calcEV(b.underPrice, cons.uP);
    }
    
    const oE = oEV && oEV >= CFG.minEV;
    const uE = uEV && uEV >= CFG.minEV;
    
    if (oE || uE) {
        const k = `${g.eventID}-${bk}-total-${b.line}-${b.overPrice}-${b.underPrice}`;
        if (!alerted.has(k)) { 
            alerted.add(k);
            if (oE) {
                triggerAlertCBB(g, bkd, 'total', 'over', b.line, b.overPrice, oEV);
                if (oEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'total', 'over', b.line, b.overPrice, oEV);
            }
            if (uE) {
                triggerAlertCBB(g, bkd, 'total', 'under', b.line, b.underPrice, uEV);
                if (uEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'total', 'under', b.line, b.underPrice, uEV);
            }
        }
    }
    
    const oClass = b.overPrice === bestOver ? 'best' : '';
    const uClass = b.underPrice === bestUnder ? 'best' : '';
    
    const oClick = b.overPrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','over',${b.line},${b.overPrice},${oEV !== null ? oEV : 'null'}); event.stopPropagation();"` : '';
    const uClick = b.underPrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','under',${b.line},${b.underPrice},${uEV !== null ? uEV : 'null'}); event.stopPropagation();"` : '';
    
    return `<tr>
        <td><div class="book-cell"><div class="book-logo" style="background:${bkd.c};color:#fff">${bkd.a}</div><span class="book-name">${bkd.n}</span></div></td>
        <td>${b.line}</td>
        <td class="odds-cell">${b.overPrice ? `<span class="odds-value clickable ${oClass}" ${oClick}>${fmt(b.overPrice)}</span>` : '--'}</td>
        <td class="odds-cell">${b.underPrice ? `<span class="odds-value clickable ${uClass}" ${uClick}>${fmt(b.underPrice)}</span>` : '--'}</td>
        <td class="ev-cell">${oEV !== null ? `<span class="ev-value${oEV >= CFG.minEV ? ' positive' : ' negative'}">${oEV > 0 ? '+' : ''}${oEV.toFixed(1)}%</span>` : '--'}</td>
        <td class="ev-cell">${uEV !== null ? `<span class="ev-value${uEV >= CFG.minEV ? ' positive' : ' negative'}">${uEV > 0 ? '+' : ''}${uEV.toFixed(1)}%</span>` : '--'}</td>
    </tr>`;
}

function mlTable(data, cons, g, period, canCalcEV) {
    if (!data || !data.books || !data.books.length) return '<div class="empty" style="padding:12px;font-size:12px">No moneyline odds</div>';
    
    const show = [...new Set([...CFG.compareBooks])];
    const filtered = data.books.filter(b => show.includes(b.bk?.toLowerCase()));
    if (!filtered.length) return '<div class="empty" style="padding:12px;font-size:12px">No odds from selected books</div>';
    
    let bestHome = -Infinity, bestAway = -Infinity;
    filtered.forEach(b => {
        if (b.homePrice) bestHome = Math.max(bestHome, b.homePrice);
        if (b.awayPrice) bestAway = Math.max(bestAway, b.awayPrice);
    });
    
    return `<table class="odds-table">
        <thead><tr><th>Book</th><th>Away</th><th>Home</th><th>A EV</th><th>H EV</th></tr></thead>
        <tbody>
            ${cons ? `<tr class="consensus-row">
                <td><span class="consensus-label">‚ö° Sharp (${cons.cnt})</span></td>
                <td>${fmt(cons.aFair)}</td>
                <td>${fmt(cons.hFair)}</td>
                <td>--</td><td>--</td>
            </tr>` : ''}
            ${filtered.map(b => mlRow(b, cons, bestAway, bestHome, g, period, canCalcEV)).join('')}
        </tbody>
    </table>`;
}

function mlRow(b, cons, bestAway, bestHome, g, period, canCalcEV) {
    const bk = (b.bk || '').toLowerCase();
    const bkd = BOOKS[bk] || {n: b.bk, a: bk.substring(0,3).toUpperCase(), c: '#666'};
    
    let aEV = null, hEV = null;
    if (cons && canCalcEV) {
        if (b.awayPrice) aEV = calcEV(b.awayPrice, cons.aP);
        if (b.homePrice) hEV = calcEV(b.homePrice, cons.hP);
    }
    
    const aE = aEV && aEV >= CFG.minEV;
    const hE = hEV && hEV >= CFG.minEV;
    
    if (aE || hE) {
        const k = `${g.eventID}-${bk}-ml-${b.awayPrice}-${b.homePrice}`;
        if (!alerted.has(k)) { 
            alerted.add(k);
            if (aE) {
                triggerAlertCBB(g, bkd, 'ml', 'away', 'ML', b.awayPrice, aEV);
                if (aEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'ml', 'away', 'ML', b.awayPrice, aEV);
            }
            if (hE) {
                triggerAlertCBB(g, bkd, 'ml', 'home', 'ML', b.homePrice, hEV);
                if (hEV >= CFG.telegramMinEV) sendTelegramCBB(g, bkd.n, 'ml', 'home', 'ML', b.homePrice, hEV);
            }
        }
    }
    
    const aClass = b.awayPrice === bestAway ? 'best' : '';
    const hClass = b.homePrice === bestHome ? 'best' : '';
    
    const aClick = b.awayPrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','away ml','ML',${b.awayPrice},${aEV !== null ? aEV : 'null'}); event.stopPropagation();"` : '';
    const hClick = b.homePrice ? `onclick="openBetSlip('${g.eventID}','${bk}','${period}','home ml','ML',${b.homePrice},${hEV !== null ? hEV : 'null'}); event.stopPropagation();"` : '';
    
    return `<tr>
        <td><div class="book-cell"><div class="book-logo" style="background:${bkd.c};color:#fff">${bkd.a}</div><span class="book-name">${bkd.n}</span></div></td>
        <td class="odds-cell">${b.awayPrice ? `<span class="odds-value clickable ${aClass}" ${aClick}>${fmt(b.awayPrice)}</span>` : '--'}</td>
        <td class="odds-cell">${b.homePrice ? `<span class="odds-value clickable ${hClass}" ${hClick}>${fmt(b.homePrice)}</span>` : '--'}</td>
        <td class="ev-cell">${aEV !== null ? `<span class="ev-value${aEV >= CFG.minEV ? ' positive' : ' negative'}">${aEV > 0 ? '+' : ''}${aEV.toFixed(1)}%</span>` : '--'}</td>
        <td class="ev-cell">${hEV !== null ? `<span class="ev-value${hEV >= CFG.minEV ? ' positive' : ' negative'}">${hEV > 0 ? '+' : ''}${hEV.toFixed(1)}%</span>` : '--'}</td>
    </tr>`;
}

function triggerAlertCBB(g, bkd, market, side, line, odds, ev) {
    const c = document.getElementById('alerts');
    const t = g.teams || {};
    const aw = t.away?.names?.short || 'Away';
    const hm = t.home?.names?.short || 'Home';
    const sideLabel = market === 'spread' ? `${side.toUpperCase()} ${line > 0 ? '+' : ''}${line}` : `${side.toUpperCase()} ${line}`;
    const id = 'a' + Date.now();
    c.insertAdjacentHTML('afterbegin', `<div class="alert" id="${id}" onclick="dismissAlert('${id}')">
        <div class="alert-header"><span class="alert-title">üèÄ ${aw} @ ${hm}</span><span class="alert-time">${new Date().toLocaleTimeString([],{hour:'numeric',minute:'2-digit'})}</span></div>
        <div class="alert-body">${bkd.n}: <strong>${sideLabel}</strong> ${fmt(odds)}<span class="alert-ev">+${ev.toFixed(1)}%</span></div>
    </div>`);
    if (CFG.sound) beep();
    setTimeout(() => dismissAlert(id), 120000);
}

async function sendTelegramCBB(game, book, market, side, line, odds, ev) {
    if (!CFG.telegramEnabled || !CFG.telegramToken || !CFG.telegramChatId) return;
    
    const key = `${game.eventID}-${book}-${market}-${side}-${line}`;
    if (telegramSent.has(key)) return;
    telegramSent.add(key);
    
    const t = game.teams || {};
    const away = t.away?.names?.short || 'Away';
    const home = t.home?.names?.short || 'Home';
    const sideLabel = market === 'spread' ? `${side.toUpperCase()} ${line > 0 ? '+' : ''}${line}` : `${side.toUpperCase()} ${line}`;
    
    const message = `üèÄ *CBB +EV Alert*

*${away} @ ${home}*
üìä ${market.toUpperCase()}: ${sideLabel}
üìï ${book}
üí∞ Odds: ${odds > 0 ? '+' : ''}${odds}
‚úÖ *EV: +${ev.toFixed(1)}%*`;

    try {
        await fetch(`https://api.telegram.org/bot${CFG.telegramToken}/sendMessage`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: CFG.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
        console.log('Telegram sent:', key);
    } catch(err) {
        console.error('Telegram error:', err);
    }
}

function hasEdge(odds, g) {
    const st = g.status || {};
    const isLive = st.started && !st.completed;
    if (isLive) return false; // No EV calcs for live
    
    for (const period of ['game', '1h']) {
        const pd = odds[period];
        if (!pd) continue;
        
        // Check spreads
        const spreadCons = consensusSpread(pd.spread.books);
        if (spreadCons) {
            for (const b of pd.spread.books) {
                if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) continue;
                if (b.awayPrice && calcEV(b.awayPrice, spreadCons.aP) >= CFG.minEV) return true;
                if (b.homePrice && calcEV(b.homePrice, spreadCons.hP) >= CFG.minEV) return true;
            }
        }
        
        // Check totals
        const totalCons = consensusTotal(pd.total.books);
        if (totalCons) {
            for (const b of pd.total.books) {
                if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) continue;
                if (b.overPrice && calcEV(b.overPrice, totalCons.oP) >= CFG.minEV) return true;
                if (b.underPrice && calcEV(b.underPrice, totalCons.uP) >= CFG.minEV) return true;
            }
        }
    }
    return false;
}
function updateStats() {
    const liveCount = DATA.filter(d => d.game.status?.started && !d.game.status?.completed).length;
    document.getElementById('sGames').textContent = DATA.length + (liveCount ? ` (${liveCount} live)` : '');
    document.getElementById('sTime').textContent = new Date().toLocaleTimeString([],{hour:'numeric',minute:'2-digit'});
    let cnt = 0, best = 0, arbCnt = 0;
    DATA.forEach(({game: g, odds}) => {
        const st = g.status || {};
        const isLive = st.started && !st.completed;
        if (isLive) return; // No EV calcs for live games in CBB
        
        ['game', '1h'].forEach(period => {
            const pd = odds[period];
            if (!pd) return;
            
            // Check spreads
            const spreadCons = consensusSpread(pd.spread.books);
            if (spreadCons) {
                pd.spread.books.forEach(b => {
                    if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
                    if (b.awayPrice) { const e = calcEV(b.awayPrice, spreadCons.aP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                    if (b.homePrice) { const e = calcEV(b.homePrice, spreadCons.hP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                });
            }
            
            // Check totals
            const totalCons = consensusTotal(pd.total.books);
            if (totalCons) {
                pd.total.books.forEach(b => {
                    if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
                    if (b.overPrice) { const e = calcEV(b.overPrice, totalCons.oP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                    if (b.underPrice) { const e = calcEV(b.underPrice, totalCons.uP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                });
            }
            
            // Check moneyline
            const mlCons = consensusML(pd.ml?.books || []);
            if (mlCons) {
                (pd.ml?.books || []).forEach(b => {
                    if (!CFG.compareBooks.includes(b.bk?.toLowerCase())) return;
                    if (b.awayPrice) { const e = calcEV(b.awayPrice, mlCons.aP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                    if (b.homePrice) { const e = calcEV(b.homePrice, mlCons.hP); if (e >= CFG.minEV) { cnt++; best = Math.max(best, e); } }
                });
            }
            
            // Count arbitrage opportunities
            if (CFG.arbEnabled) {
                const arbs = findArbitrageOpportunities(pd, g);
                arbCnt += arbs.length;
            }
        });
    });
    document.getElementById('sEV').textContent = cnt;
    document.getElementById('sBest').textContent = best > 0 ? '+' + best.toFixed(1) + '%' : '--';
    document.getElementById('sArbs').textContent = arbCnt || '0';
}

function loadDemo() {
    alerted.clear();
    telegramSent.clear();
    consensusHistory = {}; // Clear consensus history for steam alerts
    steamAlerted.clear();
    document.getElementById('debug').style.display = 'none';
    DATA = [
        {
            game: { eventID: 'd0', teams: {away: {names: {short: 'Gonzaga', abbr: 'GONZ'}}, home: {names: {short: 'Arizona', abbr: 'ARIZ'}}},
                status: {started: true, completed: false, displayShort: '2nd 12:34', period: 2, clock: '12:34'}, 
                score: {away: 42, home: 38},
                startTime: new Date(Date.now() - 1800000).toISOString() },
            odds: {
                'game': {
                    spread: { books: [
                        {bk:'pinnacle', homeLine:-4.5, awayLine:4.5, homePrice:-108, awayPrice:-112},
                        {bk:'circa', homeLine:-4.5, awayLine:4.5, homePrice:-110, awayPrice:-110},
                        {bk:'bookmaker', homeLine:-4.5, awayLine:4.5, homePrice:-109, awayPrice:-111},
                        {bk:'draftkings', homeLine:-4.5, awayLine:4.5, homePrice:-105, awayPrice:-115},
                        {bk:'fanduel', homeLine:-4.5, awayLine:4.5, homePrice:-112, awayPrice:-108},
                        {bk:'betmgm', homeLine:-4.5, awayLine:4.5, homePrice:-110, awayPrice:-110}
                    ]},
                    total: { line: 151.5, books: [
                        {bk:'pinnacle', line:151.5, overPrice:-110, underPrice:-110},
                        {bk:'circa', line:151.5, overPrice:-108, underPrice:-112},
                        {bk:'bookmaker', line:151.5, overPrice:-110, underPrice:-110},
                        {bk:'draftkings', line:151.5, overPrice:-108, underPrice:-112},
                        {bk:'fanduel', line:151.5, overPrice:-112, underPrice:-108},
                        {bk:'betmgm', line:151.5, overPrice:-105, underPrice:-115}
                    ]}
                },
                '1h': { spread: { books: [] }, total: { line: 0, books: [] } }
            }
        },
        {
            game: { eventID: 'd1', teams: {away: {names: {short: 'Duke', abbr: 'DUKE'}}, home: {names: {short: 'UNC', abbr: 'UNC'}}},
                status: {started: false, completed: false}, startTime: new Date(Date.now() + 3600000).toISOString() },
            odds: {
                'game': {
                    spread: { books: [
                        {bk:'pinnacle', homeLine:-5.5, awayLine:5.5, homePrice:-110, awayPrice:-110},
                        {bk:'circa', homeLine:-5.5, awayLine:5.5, homePrice:-108, awayPrice:-112},
                        {bk:'bookmaker', homeLine:-5.5, awayLine:5.5, homePrice:-110, awayPrice:-110},
                        {bk:'draftkings', homeLine:-5.5, awayLine:5.5, homePrice:-115, awayPrice:-105},
                        {bk:'fanduel', homeLine:-5.5, awayLine:5.5, homePrice:-108, awayPrice:-112},
                        {bk:'betmgm', homeLine:-5.5, awayLine:5.5, homePrice:-105, awayPrice:-115},
                        {bk:'caesars', homeLine:-5.5, awayLine:5.5, homePrice:-112, awayPrice:-108}
                    ]},
                    total: { line: 148.5, books: [
                        {bk:'pinnacle', line:148.5, overPrice:-110, underPrice:-110},
                        {bk:'circa', line:148.5, overPrice:-108, underPrice:-112},
                        {bk:'bookmaker', line:148.5, overPrice:-110, underPrice:-110},
                        {bk:'draftkings', line:148.5, overPrice:-115, underPrice:-105},
                        {bk:'fanduel', line:148.5, overPrice:-105, underPrice:-115},
                        {bk:'betmgm', line:148.5, overPrice:105, underPrice:-125},
                        {bk:'caesars', line:148.5, overPrice:-108, underPrice:-112}
                    ]}
                },
                '1h': {
                    spread: { books: [
                        {bk:'pinnacle', homeLine:-2.5, awayLine:2.5, homePrice:-110, awayPrice:-110},
                        {bk:'draftkings', homeLine:-2.5, awayLine:2.5, homePrice:-120, awayPrice:100},
                        {bk:'fanduel', homeLine:-2.5, awayLine:2.5, homePrice:-105, awayPrice:-115}
                    ]},
                    total: { line: 72.5, books: [
                        {bk:'pinnacle', line:72.5, overPrice:-110, underPrice:-110},
                        {bk:'draftkings', line:72.5, overPrice:-112, underPrice:-108},
                        {bk:'fanduel', line:72.5, overPrice:-108, underPrice:-112}
                    ]}
                }
            }
        },
        {
            game: { eventID: 'd2', teams: {away: {names: {short: 'Kentucky', abbr: 'UK'}}, home: {names: {short: 'Kansas', abbr: 'KU'}}},
                status: {started: false, completed: false}, startTime: new Date(Date.now() + 7200000).toISOString() },
            odds: {
                'game': {
                    spread: { books: [
                        {bk:'pinnacle', homeLine:-3.5, awayLine:3.5, homePrice:-112, awayPrice:-108},
                        {bk:'circa', homeLine:-3.5, awayLine:3.5, homePrice:-110, awayPrice:-110},
                        {bk:'bookmaker', homeLine:-3.5, awayLine:3.5, homePrice:-108, awayPrice:-112},
                        {bk:'draftkings', homeLine:-3.5, awayLine:3.5, homePrice:-105, awayPrice:-115},
                        {bk:'fanduel', homeLine:-3.5, awayLine:3.5, homePrice:-118, awayPrice:-102},
                        {bk:'betmgm', homeLine:-3.5, awayLine:3.5, homePrice:-110, awayPrice:-110}
                    ]},
                    total: { line: 156.5, books: [
                        {bk:'pinnacle', line:156.5, overPrice:-108, underPrice:-112},
                        {bk:'circa', line:156.5, overPrice:-110, underPrice:-110},
                        {bk:'bookmaker', line:156.5, overPrice:-112, underPrice:-108},
                        {bk:'draftkings', line:156.5, overPrice:-105, underPrice:-115},
                        {bk:'fanduel', line:156.5, overPrice:-115, underPrice:-105},
                        {bk:'betmgm', line:156.5, overPrice:100, underPrice:-120}
                    ]}
                },
                '1h': {
                    spread: { books: [] },
                    total: { line: 0, books: [] }
                }
            }
        }
    ];
    render();
    updateStats();
    setStatus(true, 'Demo');
}
</script>
</body>
</html>
